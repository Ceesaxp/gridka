## 2026-02-15 - US-001 - Bootstrap Xcode project with AppKit window
- Created project directory structure: Sources/App/, Sources/Engine/, Sources/Model/, Sources/UI/, Sources/Bridging/, Libraries/, Resources/, Tests/
- Created project.yml targeting macOS 14.0+ with Swift 5.10, bundle ID com.gridka.app
- Created Sources/App/AppDelegate.swift with NSApplicationDelegate that creates main NSWindow (title "Gridka", 1200x800)
- Created Sources/App/main.swift with NSApplication.shared setup
- Created Resources/Assets.xcassets with empty AppIcon set
- Created Tests/GridkaTests.swift placeholder for test target
- Generated Gridka.xcodeproj with xcodegen
- Build succeeds with zero warnings/errors
- **Learnings for future iterations:**
  - xcodegen is already installed at /opt/homebrew/bin/xcodegen
  - project.yml uses GENERATE_INFOPLIST_FILE: YES so no manual Info.plist needed
  - The test target uses BUNDLE_LOADER/TEST_HOST pattern for host app testing
  - Empty source directories need at least one file for xcodegen to include them in targets
  - The generated .xcodeproj should be gitignored since it's reproducible from project.yml
----

## 2026-02-15 - US-002 - Vendor DuckDB and configure bridging header
- Downloaded DuckDB v1.2.1 macOS universal library from GitHub releases to Libraries/
- DuckDB release provides libduckdb.dylib (dynamic library), not a static .a — project configured for dylib linking
- Created Sources/Bridging/Gridka-Bridging-Header.h with `#include "duckdb.h"`
- Updated project.yml: SWIFT_OBJC_BRIDGING_HEADER, HEADER_SEARCH_PATHS, LIBRARY_SEARCH_PATHS, OTHER_LDFLAGS (-lduckdb, -lc++)
- Added LD_RUNPATH_SEARCH_PATHS for @executable_path/../Frameworks and $(PROJECT_DIR)/Libraries
- Added postCompileScript to copy libduckdb.dylib into app bundle's Frameworks directory
- Added smoke test in AppDelegate.swift: duckdb_open(nil, &db) + duckdb_close(&db) — verifies linking works
- Created Libraries/download-duckdb.sh script for fetching DuckDB (dylib is too large for git, .gitignored)
- Libraries/duckdb.h committed to git; libduckdb.dylib is .gitignored
- Build succeeds, tests pass, no warnings
- **Learnings for future iterations:**
  - DuckDB macOS release only provides .dylib (not .a static lib) — must configure dylib embedding
  - DuckDB C API types in Swift: `duckdb_database` maps to `UnsafeMutablePointer<_duckdb_database>?`, not `OpaquePointer?`
  - postCompileScripts in project.yml need inputFiles/outputFiles to avoid "run every build" warnings
  - The dylib install name is just `libduckdb.dylib` — rpath must include Frameworks dir
  - DuckDB open returns `DuckDBSuccess` constant (not a raw Int)
----

## 2026-02-15 - US-003 - Implement GridkaError and DuckDBTypes
- Created Sources/Engine/GridkaError.swift with enum GridkaError: LocalizedError containing cases: databaseInitFailed, connectionFailed, queryFailed(String), fileNotFound(String), loadFailed(String)
- Created Sources/Bridging/DuckDBTypes.swift with:
  - enum DuckDBColumnType: varchar, integer, bigint, double, float, boolean, date, timestamp, blob, unknown — mapped from duckdb_type C constants via static mapType(from:)
  - enum DisplayType: text, integer, float, date, boolean, unknown
  - enum DuckDBValue: string(String), integer(Int64), double(Double), boolean(Bool), date(String), null — conforms to Equatable and CustomStringConvertible
- Regenerated Gridka.xcodeproj, build succeeds, tests pass
- **Learnings for future iterations:**
  - DuckDB C enum values (DUCKDB_TYPE_VARCHAR, etc.) are available directly in Swift via the bridging header — no need for raw values
  - DuckDB has many integer subtypes (TINYINT, SMALLINT, UTINYINT, etc.) — map them all to the appropriate DuckDBColumnType
  - DuckDB timestamps have multiple variants (TIMESTAMP, TIMESTAMP_S, TIMESTAMP_MS, TIMESTAMP_NS, TIMESTAMP_TZ) — all mapped to .timestamp
  - HUGEINT and UHUGEINT are 128-bit integers — mapped to .bigint since Swift Int64 is used for display
----

## 2026-02-15 - US-004 - Implement DuckDBEngine core wrapper
- Created Sources/Engine/DuckDBEngine.swift as a final class wrapping DuckDB C API
- DuckDBEngine.init() opens in-memory database with duckdb_open, creates connection with duckdb_connect
- Configures memory_limit to 50% of system RAM (via ProcessInfo.processInfo.physicalMemory)
- Configures temp_directory to ~/Library/Caches/com.gridka.app/duckdb-temp/
- Configures threads to active processor count
- func execute(_ sql: String) throws -> DuckDBResult wraps duckdb_query with error handling
- Created DuckDBResult as a final class wrapping duckdb_result with: rowCount, columnCount, columnName(at:), columnType(at:), value(row:col:) -> DuckDBValue
- DuckDBResult.value() extracts typed values based on column type: boolean, integer types, float, double/decimal, date, timestamp, and varchar fallback
- duckdb_value_varchar results are properly freed with duckdb_free
- DuckDBResult.deinit calls duckdb_destroy_result; DuckDBEngine.deinit calls duckdb_disconnect + duckdb_close
- GRIDKA_LOG_SQL=1 environment variable support via os.log Logger
- @discardableResult on execute() for SET commands that don't need result inspection
- Build succeeds, tests pass
- **Learnings for future iterations:**
  - duckdb_result is a value type in C but contains internal pointers — must use `var` and pass with `&` for DuckDB API calls
  - DuckDBResult stores rowCount/columnCount eagerly in init since the result pointer is needed
  - duckdb_value_varchar returns a malloc'd char* that must be freed with duckdb_free (not Swift's dealloc)
  - The deprecated duckdb_value_* functions (boolean, int64, float, double, varchar, is_null) are still the simplest way to extract values from duckdb_result — the newer chunk-based API is more complex but faster
  - os.log Logger (import os.log) is the modern replacement for NSLog/os_log for structured logging
  - ProcessInfo.processInfo.activeProcessorCount gives logical cores (not physical), suitable for DuckDB thread config
----

## 2026-02-15 - US-005 - Implement model types: ViewState, ColumnDescriptor, ColumnFilter
- Created Sources/Model/ColumnDescriptor.swift: struct with name, duckDBType, displayType, index — conforms to Equatable and Hashable
- Created Sources/Model/ViewState.swift with:
  - enum SortDirection: ascending, descending (Equatable, Hashable)
  - struct SortColumn: column + direction (Equatable, Hashable) — used instead of tuple since tuples can't conform to Equatable
  - struct ViewState: sortColumns, filters, searchTerm, visibleRange, totalFilteredRows (Equatable)
- Created Sources/Model/ColumnFilter.swift with:
  - enum FilterOperator: all 17 operator cases (contains, equals, startsWith, endsWith, regex, isEmpty, isNotEmpty, greaterThan, lessThan, greaterOrEqual, lessOrEqual, between, isNull, isNotNull, isTrue, isFalse) — Equatable, Hashable
  - enum FilterValue: string, number, dateRange, boolean, none — Equatable, Hashable
  - struct ColumnFilter: column, operator, value — Equatable, Hashable
- Added Hashable conformance to DuckDBColumnType and DisplayType in DuckDBTypes.swift (needed for ColumnDescriptor Hashable)
- Regenerated Gridka.xcodeproj, build succeeds, tests pass
- **Learnings for future iterations:**
  - PRD specifies sortColumns as `[(column: String, direction: SortDirection)]` tuple array, but Swift tuples can't conform to Equatable/Hashable — use a named SortColumn struct instead
  - `operator` is a Swift keyword — must use backticks when used as property name: `let \`operator\`: FilterOperator`
  - Simple enums without associated values auto-synthesize Hashable, but enums with associated values need all associated types to be Hashable
  - ViewState uses `var` properties since it's a value type that gets mutated to produce new states
----

## 2026-02-15 - US-006 - Implement QueryCoordinator with unit tests
- Created Sources/Engine/QueryCoordinator.swift as a final class with no stored state
- func buildQuery(for:columns:range:) generates SELECT * FROM data with optional WHERE, ORDER BY, LIMIT/OFFSET
- func buildCountQuery(for:columns:) generates SELECT COUNT(*) FROM data with optional WHERE (no ORDER BY)
- WHERE clause: filters combined with AND, global search ORs across all columns cast to TEXT with ILIKE
- ORDER BY: respects sortColumns order, each with ASC/DESC and NULLS LAST
- LIMIT/OFFSET: derived from range parameter
- Static helpers: quote() double-quotes identifiers, escape() handles single quotes, backslashes, percent, and underscore for ILIKE
- All filter operators implemented: contains, equals (string+numeric), startsWith, endsWith, regex, isEmpty, isNotEmpty, greaterThan, lessThan, greaterOrEqual, lessOrEqual, between, isNull, isNotNull, isTrue, isFalse
- Global search excludes _gridka_rowid column
- Numeric formatting: whole numbers rendered as integers (25 not 25.0), decimals preserved
- Created Tests/QueryCoordinatorTests.swift with 38 test cases covering: bare select, offset, count query, single filter, multiple filters AND, global search, search excluding _gridka_rowid, empty search term, single sort asc/desc, multi-column sort, combined filter+sort+search, all 17 filter operator types, quote/escape helpers, SQL injection prevention, numeric formatting
- Fixed project.yml: added HEADER_SEARCH_PATHS to GridkaTests target (test target couldn't find duckdb.h from bridging header)
- All 39 tests pass (38 QueryCoordinator + 1 placeholder), build succeeds
- **Learnings for future iterations:**
  - The GridkaTests target needs HEADER_SEARCH_PATHS pointing to Libraries/ because the bridging header includes duckdb.h — without this the test target fails to compile
  - QueryCoordinator is purely stateless — it takes ViewState and columns as parameters and returns SQL strings. No DuckDB dependency needed for testing.
  - ILIKE patterns need ESCAPE '\\' clause when using escape() helper that escapes %, _, and \ characters
  - DuckDB uses ~ for regex matching (POSIX regex operator)
  - between operator uses FilterValue.dateRange(low, high) for both date ranges and numeric ranges
  - Numeric values from FilterValue.number(Double) should be formatted as integers when they have no fractional part to produce cleaner SQL
----

## 2026-02-15 - US-007 - Implement RowCache with unit tests
- Created Sources/Engine/RowCache.swift as a struct (value type) implementing LRU page cache
- Page size constant: 500 rows, max cached pages: 20 (10,000 rows max in memory)
- Inner struct Page: startRow, data as [[DuckDBValue]], columnNames as [String], lastAccessed as Date
- func value(forRow:columnName:) returns DuckDBValue? — nil on cache miss
- mutating func touchPage(forRow:) — updates lastAccessed for LRU tracking on access
- mutating func insertPage(_:) — adds page, triggers LRU eviction if over maxCachedPages limit
- mutating func invalidateAll() — clears all cached pages (for filter/sort changes)
- func pageIndex(forRow:) and func pageRange(forPageIndex:) for page math
- LRU eviction: evicts page with oldest lastAccessed timestamp
- Created Tests/RowCacheTests.swift with 12 test cases covering: cache miss returns nil, wrong column returns nil, insert then hit returns value, different column types, multiple rows, page index math (row 0→page 0, row 499→page 0, row 500→page 1), page range calculation, eviction at 21 pages evicts oldest, invalidateAll clears everything, out-of-bounds row returns nil, constant verification
- All 51 tests pass (12 RowCache + 38 QueryCoordinator + 1 placeholder), build succeeds
- **Learnings for future iterations:**
  - RowCache is a value type (struct) — mutating methods produce new state, consistent with the ViewState immutability pattern
  - Page lookup by columnName uses firstIndex(of:) on columnNames array — column order in Page must match data column order
  - LRU eviction uses Dictionary.min(by:) to find the oldest lastAccessed page — O(n) but with max 20 pages this is fine
  - touchPage(forRow:) is separate from value(forRow:columnName:) because value() is non-mutating for ergonomic read-only access
  - Pages are keyed by page index (row / pageSize) in a [Int: Page] dictionary for O(1) lookup
----

## 2026-02-15 - US-010 - Implement file opening flow with drag-drop and menu
- Rewrote Sources/App/AppDelegate.swift with full file opening flow:
  - File > Open menu item (⌘O) opens NSOpenPanel filtered to csv, tsv, txt file types using UTType (.commaSeparatedText, .tabSeparatedText, .plainText)
  - Empty state view with centered "Drop a CSV file or ⌘O to open" label (system font, secondary label color)
  - File opening creates FileSession, calls loadPreview, configures TableViewController, then starts background loadFull
  - Window title updates to show filename ("Gridka — filename.csv")
  - NSApplication openFile delegate method for Finder double-click support
  - Error handling via NSAlert sheet on the window
  - Main menu setup: App menu (About, Quit), File menu (Open, Close), Edit menu (Copy, Select All), Window menu (Minimize, Zoom)
- Created Sources/UI/DragDropView.swift:
  - NSView subclass that registers for .fileURL dragging type
  - Validates file extensions (csv, tsv, txt, dsv) before accepting drop
  - Uses readObjects(forClasses:options:) with urlReadingFileURLsOnly for safe URL extraction
  - onFileDrop closure callback to AppDelegate
- Window contentView is replaced with DragDropView to accept drops anywhere in the window
- Empty state ↔ table view transition: removes old view, adds new view with Auto Layout constraints
- Build succeeds, all 51 tests pass
- **Learnings for future iterations:**
  - NSOpenPanel.allowedContentTypes uses UTType from UniformTypeIdentifiers — .commaSeparatedText and .tabSeparatedText are the correct UTTypes for CSV/TSV
  - DragDropView must be the window's contentView (not a subview) to receive drops across the entire window area
  - registerForDraggedTypes([.fileURL]) is the modern way to accept file drops — NSDragOperation.copy is returned for valid files
  - readObjects(forClasses:options:) with [.urlReadingFileURLsOnly: true] filters out non-file URLs safely
  - The main menu must be set programmatically since there are no storyboards — NSApp.mainMenu = menu
  - application(_:openFile:) on NSApplicationDelegate handles files opened from Finder double-click
  - TableViewController is held as a strong reference on AppDelegate to prevent deallocation (its view is just a subview)
----

## 2026-02-15 - US-008 - Implement FileSession with serial query queue
- Created Sources/Model/FileSession.swift as a final class coordinating all DuckDB queries
- Properties: filePath (URL), engine (DuckDBEngine), tableName, columns, viewState, rowCache, isFullyLoaded
- Private serial DispatchQueue named 'com.gridka.query-queue' for all DuckDB calls
- func loadPreview(completion:) runs SELECT * FROM read_csv_auto(...) LIMIT 1000 on query queue, extracts column metadata, creates initial RowCache page, dispatches result to main
- func loadFull(progress:completion:) runs CREATE TABLE data AS SELECT row_number() OVER () AS _gridka_rowid, * FROM read_csv_auto(...) on query queue with ignore_errors=true, then COUNT(*), re-extracts columns from materialized table, dispatches to main
- func fetchPage(index:completion:) uses QueryCoordinator to build SQL from current viewState, executes on query queue, returns RowCache.Page
- func updateViewState(_:) invalidates rowCache when filters/sort/search change, triggers count re-query via requeryCount()
- All DuckDB execute calls happen exclusively on the serial query queue
- All completion handlers dispatch back to DispatchQueue.main
- File existence check in init() throws GridkaError.fileNotFound for missing files
- Private helpers: extractColumns, extractPage, extractRowData, mapDisplayType — reuse DuckDBResult to build model types
- Regenerated Gridka.xcodeproj, build succeeds, all 51 tests pass
- **Learnings for future iterations:**
  - FileSession owns the DuckDBEngine instance — it's the only object that calls engine.execute()
  - RowCache is a struct (value type) stored as var on FileSession — mutating methods work because FileSession is a class
  - loadFull re-extracts columns via SELECT * FROM data LIMIT 0 after materialization because the table now includes _gridka_rowid
  - File path escaping for SQL: single quotes in paths must be doubled for DuckDB SQL strings
  - Progress callback during loadFull is approximate (0.0 → 0.8 after CREATE TABLE, 0.8 → 1.0 after COUNT) since DuckDB doesn't provide granular progress for CREATE TABLE AS
  - updateViewState compares filters/sort/search to detect if cache invalidation is needed — visible range changes alone don't invalidate
  - The serial query queue prevents concurrent DuckDB access since DuckDB connections are not thread-safe
----

## 2026-02-15 - US-009 - Implement TableViewController with NSTableView data source
- Created Sources/UI/TableViewController.swift as a final class extending NSViewController
- NSScrollView wrapping NSTableView in view-based mode with vertical and horizontal scrollers
- NSTableViewDataSource: numberOfRows returns fileSession.viewState.totalFilteredRows
- NSTableViewDelegate: tableView(_:viewFor:row:) returns NSTextField-based cells with cell recycling via makeView(withIdentifier:owner:)
- Cache miss handling: shows "..." placeholder in gray, triggers async page fetch via FileSession.fetchPage, reloads affected rows on completion
- Deduplication of page fetch requests via fetchingPages Set to prevent multiple concurrent fetches of the same page
- func configureColumns(_:) dynamically creates NSTableColumn per ColumnDescriptor, skipping _gridka_rowid
- Column headers show name + type indicator: "age (int)", "name (text)", etc.
- Cell text formatting: integers with grouping separator (NumberFormatter), floats with 2 decimal places, dates as ISO strings, booleans as "true"/"false", nulls as italic gray "NULL"
- Numeric columns (integer, float) are right-aligned; text/date/boolean are left-aligned
- Monospaced digit font (NSFont.monospacedDigitSystemFont) for tabular number alignment
- Regenerated Gridka.xcodeproj, build succeeds, all 51 tests pass
- **Learnings for future iterations:**
  - NSTableView property is `usesAlternatingRowBackgroundColors` (not `usesAlternatingRowBackgrounds`) — the latter doesn't exist and causes compile error
  - NSFont italic helper: use `fontDescriptor.withSymbolicTraits(.italic)` then `NSFont(descriptor:size:)` — returns optional since not all fonts have italic variant
  - Cell recycling in view-based NSTableView: use `makeView(withIdentifier:owner:)` which returns NSView? — cast to NSTextField for reuse
  - The fetchingPages Set prevents duplicate page requests when NSTableView calls viewFor delegate rapidly for visible rows in the same uncached page
  - NSTableColumn identifier uses the column name string — matches RowCache columnName for direct lookup
  - columnAutoresizingStyle = .noColumnAutoresizing prevents auto-shrinking columns when window resizes
----

## 2026-02-15 - US-011 - Implement progressive loading and status bar
- Created Sources/UI/StatusBarView.swift: 22pt horizontal bar at the bottom of the window
  - Shows total rows ("X rows" or "showing X of Y rows" when filtered), file size, load time
  - During background load shows "Loading… X%" progress text
  - Uses NSFont.monospacedDigitSystemFont for number alignment
  - Uses ByteCountFormatter for human-readable file sizes
  - NSBox separator at the top for visual separation from the table
- Modified Sources/UI/TableViewController.swift:
  - Added StatusBarView as a subview pinned to the bottom of the container
  - ScrollView bottom constraint now anchors to statusBar.topAnchor instead of container bottom
- Modified Sources/App/AppDelegate.swift:
  - On file open: reads file size via FileManager attributes, updates status bar
  - Tracks load start time with CFAbsoluteTimeGetCurrent()
  - Preview load immediately shows row count in status bar
  - Full background load updates progress via progress callback
  - On full load completion: updates load time, row count, and clears progress
  - Seamless swap: after full load, only reassigns fileSession (triggers reloadData) without reconfiguring columns — preserves scroll position
- Regenerated Gridka.xcodeproj, build succeeds, all 51 tests pass
- **Learnings for future iterations:**
  - ByteCountFormatter with .file countStyle is the standard way to format file sizes on macOS
  - CFAbsoluteTimeGetCurrent() is a lightweight wall-clock timer suitable for measuring load times
  - FileManager.attributesOfItem(atPath:)[.size] returns file size as UInt64 — cast to Int64 for ByteCountFormatter
  - When swapping from preview to full table, don't call configureColumns again — the columns are the same (just with _gridka_rowid added which is hidden). Just reassigning fileSession triggers reloadData which picks up the new totalFilteredRows without resetting scroll position.
  - StatusBarView height constraint of 22pt is standard for macOS status bars
  - NSBox with .separator boxType provides the standard system divider line
----

## 2026-02-15 - US-012 - Implement column sorting
- Implemented column header click sorting in TableViewController via `tableView(_:didClick:)` delegate method
- Click cycle: first click → ascending, second click → descending, third click → removes sort
- Shift+click adds secondary/tertiary sort keys (multi-column sort)
- Sort indicators in column headers: ▲ for ascending, ▼ for descending; multi-sort shows numbered indicators (1▲, 2▼)
- Added `onSortChanged` callback on TableViewController for AppDelegate to wire up the sorting flow
- Added `updateSortIndicators()` method that updates column header titles to reflect current sort state
- AppDelegate `handleSortChanged()` updates ViewState, invalidates cache, re-fetches visible page, reloads table
- StatusBarView gains `showQueryTime()` method that briefly shows query execution time (auto-clears after 3 seconds)
- Sorting is disabled during preview mode (before full load completes) via `isFullyLoaded` guard
- Files changed: Sources/UI/TableViewController.swift, Sources/UI/StatusBarView.swift, Sources/App/AppDelegate.swift
- Build succeeds, all 51 tests pass
- **Learnings for future iterations:**
  - NSTableView `tableView(_:didClick:)` delegate fires when user clicks column headers — this is the hook for sort interaction
  - NSEvent.modifierFlags is a static property that gives current modifier key state — use `.contains(.shift)` to detect shift+click
  - Sort indicators are rendered as Unicode arrows (▲ U+25B2, ▼ U+25BC) directly in the column title string — simpler than using NSTableColumn's built-in sortIndicatorImage
  - Multi-sort numbering (1▲, 2▼) uses array index + 1 from ViewState.sortColumns
  - The `onSortChanged` closure pattern keeps TableViewController decoupled from AppDelegate — TVC handles UI, AppDelegate handles data flow
  - FileSession.updateViewState() already handles cache invalidation when sortColumns change — just need to trigger a page re-fetch after
  - `tableView.rows(in: tableView.visibleRect).location` gives the first visible row index for determining which page to re-fetch after sort
----

## 2026-02-15 - US-013 - Implement column filter SQL generation for all operator types
- Enhanced QueryCoordinator comparison operators (greaterThan, lessThan, greaterOrEqual, lessOrEqual) to accept both .number and .string filter values — enabling date column filtering with string date values (e.g., "2023-01-01")
- Numeric between already worked via dateRange(low, high) pattern — confirmed and tested
- Added 13 new test cases covering:
  - Date comparison operators: greaterThan, lessThan, greaterOrEqual, lessOrEqual with string values
  - Date between and numeric between via dateRange
  - SQL injection prevention for date strings, between values, equals strings, and regex patterns
  - Multiple filters (3-way AND), filter+search combination
  - Invalid filter value gracefully ignored (no WHERE clause generated)
- Files changed: Sources/Engine/QueryCoordinator.swift, Tests/QueryCoordinatorTests.swift, plans/prd.json
- All 64 tests pass (51 original + 13 new), build succeeds
- **Learnings for future iterations:**
  - The comparison operators (greaterThan, lessThan, etc.) in US-006 originally only accepted .number values — US-013 extends them to also accept .string values for date comparisons
  - The between operator uses FilterValue.dateRange(low, high) for both date ranges AND numeric ranges — the PRD confirms this design choice
  - All string values interpolated into SQL use .replacingOccurrences(of: "'", with: "''") for single-quote escaping — this is applied at each call site rather than through the escape() helper (which is for ILIKE patterns with %, _, \\ escaping)
  - Invalid filter values (e.g., boolean value for greaterThan operator) cause buildFilterCondition to return nil, which silently drops the filter — the query still executes, just without that filter condition
----

## 2026-02-15 - US-014 - Implement filter bar UI with column header menus
- Created Sources/UI/FilterBarView.swift: horizontal bar showing active filters as removable chip views
  - FilterBarView manages a stack of FilterChipView instances, each with column name, operator, value label, and an X close button
  - Auto-hides when no filters are active (height constraint transitions between 0 and 30pt)
  - Chips use accent-colored rounded rect backgrounds with layer-based rendering
  - onFilterRemoved callback triggers filter removal flow back through AppDelegate
- Created Sources/UI/FilterPopoverViewController.swift: popover for creating column filters
  - Adapts operator dropdown based on column DisplayType: text columns show text operators (contains, equals, startsWith, etc.), numeric/date columns show comparison operators, boolean columns show isTrue/isFalse
  - Value field hidden for operators that don't need a value (isNull, isEmpty, isTrue, etc.)
  - "Between" operator shows a second value field with "and" label
  - Numeric values parsed as Double for .number FilterValue, strings used for date columns
  - Apply button (Enter key) builds ColumnFilter and triggers onApply callback
- Added right-click context menu on column headers in TableViewController
  - NSMenu with NSMenuDelegate to dynamically populate based on right-clicked column
  - Mouse screen coordinates converted to header view local coordinates to determine clicked column
  - "Filter 'columnName'..." menu item stores column name as representedObject (NSString, not struct)
  - Clicking menu item shows FilterPopoverViewController positioned relative to header view
- Wired filter bar into TableViewController layout
  - FilterBarView sits between container top and scrollView top
  - scrollView.topAnchor now anchors to filterBar.bottomAnchor instead of container top
  - onFiltersChanged callback pattern matches existing onSortChanged pattern
- Wired filter handling into AppDelegate
  - handleFiltersChanged updates ViewState.filters, invalidates cache via updateViewState, re-fetches page 0
  - Status bar shows "showing X of Y rows" using new FileSession.totalRows property for unfiltered total
  - Added FileSession.totalRows property to track unfiltered row count (set during loadFull)
- Files changed: Sources/UI/FilterBarView.swift (new), Sources/UI/FilterPopoverViewController.swift (new), Sources/UI/TableViewController.swift, Sources/App/AppDelegate.swift, Sources/Model/FileSession.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - ColumnDescriptor is a struct and can't be used as NSMenuItem.representedObject directly — store the column name as NSString instead and look up the descriptor from FileSession.columns
  - NSTableHeaderView.column(at:) takes a point in the header view's local coordinate space — must convert from screen coordinates via window.convertPoint(fromScreen:) then headerView.convert(_:from:nil)
  - NSPopover.behavior = .transient auto-dismisses on click outside — no manual dismiss handling needed
  - The filter bar height is managed via a stored NSLayoutConstraint — toggling isHidden + updating constant is the simplest approach
  - FilterPopoverViewController adjusts its preferredContentSize dynamically based on which fields are visible (between needs more height, no-value operators need less)
  - The filter removal flow: FilterChipView.closeClicked → FilterBarView.onFilterRemoved → TableViewController.removeFilter → onFiltersChanged → AppDelegate.handleFiltersChanged — this keeps each layer decoupled
  - FileSession.totalRows stores the unfiltered count separately from viewState.totalFilteredRows, which changes when filters are applied
----

## 2026-02-15 - US-015 - Implement global search
- Created Sources/UI/SearchBarView.swift: horizontal bar with NSTextField search field, match count label, Previous/Next chevron buttons, and close button
  - SearchBarView manages 300ms debounce via DispatchWorkItem — cancels and re-schedules on each keystroke
  - Escape key dismisses search bar via NSTextFieldDelegate's `control(_:textView:doCommandBy:)` intercepting `cancelOperation:`
  - show() focuses the search field via `window?.makeFirstResponder(searchField)`
  - dismiss() clears the field, resets match count, hides the bar, and fires onSearchChanged("") to clear the search
  - updateMatchCount() displays "X rows match" or "No matches" in the match count label
- Modified Sources/UI/TableViewController.swift:
  - Added searchBar property and onSearchChanged callback
  - SearchBarView inserted between filterBar and scrollView in layout constraints
  - toggleSearchBar() method for ⌘F — shows or dismisses the search bar
  - navigateMatch(direction:) scrolls the table by one visible page up/down for Previous/Next
  - onDismiss callback returns focus to the tableView
- Modified Sources/App/AppDelegate.swift:
  - Added Find…(⌘F), Find Next (⌘G), Find Previous (⇧⌘G) menu items to Edit menu
  - performFind/performFindNext/performFindPrevious action methods route to search bar
  - handleSearchChanged() updates ViewState.searchTerm, invalidates cache, re-fetches page 0, updates status bar and match count
  - onSearchChanged callback wired in showTableView()
  - Search only enabled when file is fully loaded (isFullyLoaded guard)
- Files changed: Sources/UI/SearchBarView.swift (new), Sources/UI/TableViewController.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - NSViewController doesn't have a `window` property — use `view.window` instead (caused initial compile error)
  - DispatchWorkItem-based debouncing: cancel previous work item, create new one, schedule with asyncAfter — simple and effective pattern
  - NSTextFieldDelegate's `control(_:textView:doCommandBy:)` returns true to indicate the command was handled — returning true for `cancelOperation:` prevents the Escape key from propagating
  - NSMenuItem keyEquivalentModifierMask defaults to .command — for ⇧⌘G, explicitly set to [.command, .shift]
  - The search bar layout slots between filterBar.bottomAnchor and scrollView.topAnchor — when hidden (height=0), the space collapses seamlessly
  - Search flow mirrors filter flow: update ViewState → cache invalidation → fetchPage(0) → reload visible rows → update status bar counts
  - Match count uses viewState.totalFilteredRows after requeryCount completes — same async pattern as filters with 0.1s delay for count query
----

## 2026-02-15 - US-016 - Implement column management: resize, reorder, hide/show, auto-fit
- Column resize by dragging header borders already enabled (allowsColumnResizing = true)
- Column reorder by dragging headers already enabled (allowsColumnReordering = true)
- Added hiddenColumns (Set<String>) and allColumnDescriptors ([ColumnDescriptor]) tracking to TableViewController
- configureColumns() now stores all descriptors and skips hidden columns when building NSTableColumns
- Right-click column header context menu extended with:
  - "Hide Column" option (disabled when only 1 column visible to prevent hiding all columns)
  - "Show Columns >" submenu listing all hidden columns with type labels, only shown when hidden columns exist
- hideColumn() removes the NSTableColumn from the table view and adds to hiddenColumns set
- showColumn() re-creates the NSTableColumn and inserts it at the correct position based on original column order
- Created AutoFitTableHeaderView: custom NSTableHeaderView subclass that detects double-click on column border dividers
  - columnBorderIndex(at:) uses 4pt threshold to detect clicks near column right edges
  - Triggers autoFitColumn(at:) which scans visible rows for max content width via NSAttributedString.size()
  - Falls back to header title width as minimum, applies 16pt padding, respects min/max column constraints
- Column management state (hiddenColumns set) persists during the session — survives sort/filter/search changes
- Files changed: Sources/UI/TableViewController.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - NSTableView natively supports column resize and reorder — just set allowsColumnResizing and allowsColumnReordering
  - For hide/show, maintaining a Set<String> of hidden column names is simpler than tracking NSTableColumn objects (which get destroyed on remove)
  - When restoring a hidden column, need to calculate the correct insertion position by comparing against allColumnDescriptors order — addTableColumn always appends, then moveColumn repositions
  - AutoFitTableHeaderView subclasses NSTableHeaderView to intercept double-clicks — checking event.clickCount == 2 in mouseDown and computing column border proximity from cumulative column widths + intercell spacing
  - NSAttributedString.size() returns the bounding rect size for rendered text — useful for measuring column content width without creating actual views
  - The "Show Columns" submenu uses allColumnDescriptors filtered by hiddenColumns to preserve original column order in the menu
----

## 2026-02-15 - US-017 - Implement data inspection: detail pane and copy operations
- Created Sources/UI/DetailPaneView.swift: shows full content of selected cell with column metadata
  - Displays column name, data type, character count, and full value text
  - Uses monospace font for long text, URLs, and JSON-like content
  - Scrollable NSTextView for large values
  - Empty state prompt ("Click a cell to inspect") when no cell is selected
- Modified Sources/UI/TableViewController.swift:
  - Added NSSplitView layout: top = table scroll view, bottom = detail pane (120pt initial height)
  - Added cell selection tracking: selectedRow and selectedColumnName properties
  - Click on a cell (via tableView.action) updates the detail pane with full value
  - Right-click context menu on table cells: Copy Cell, Copy Row, Copy with Headers
  - Cell context menu uses NSMenu.identifier to differentiate from column header context menu
  - Copy Cell (⌘C): copies selected cell value to clipboard
  - Copy Row (⇧⌘C): copies all values in selected row as tab-separated text
  - Copy Column (⌥⌘C): copies all visible values in selected column as newline-separated text
  - Copy with Headers: prepends column name(s) as first line to row copy
  - toggleDetailPane() method hides/shows the detail pane via splitView arrangedSubviews
- Modified Sources/App/AppDelegate.swift:
  - Replaced generic "Copy" menu item with specific Copy Cell (⌘C), Copy Row (⇧⌘C), Copy Column (⌥⌘C) items
  - Added View menu with Toggle Detail Pane (⇧⌘D) item
  - Added action methods routing to TableViewController copy/toggle methods
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - NSSplitView with addArrangedSubview is the modern way to create split views — no need for delegate-based configuration
  - splitView.setPosition(_:ofDividerAt:) must be called after layout is complete (use DispatchQueue.main.async) to work correctly
  - setHoldingPriority(.defaultHigh) on the detail pane keeps it at a fixed size when the window resizes, while the table resizes
  - NSTableView.action + target fires on single row click — the clicked column index is available via tableView.clickedColumn
  - NSMenu.identifier distinguishes between multiple menus using the same NSMenuDelegate (header menu vs cell context menu)
  - NSSplitView arrangedSubviews need wrapper container NSViews since the split view manages their frames directly
  - Tab-separated format for Copy Row enables direct paste into spreadsheets (Excel, Numbers, Google Sheets)
  - NSPasteboard.general.clearContents() must be called before setString() — otherwise the paste may contain stale data
----

## 2026-02-15 - US-018 - Implement scroll pre-fetching and performance optimizations
- Added scroll direction detection via NSView.boundsDidChangeNotification on scrollView.contentView
- Pre-fetches 2 pages ahead in the detected scroll direction (up or down)
- Added RowCache.hasPage(_:) method for efficient cache hit checking during pre-fetch
- Optimized FileSession.updateViewState to only re-query count when filters/search change (not on sort-only changes, since sort doesn't affect row count)
- Count query result is effectively cached — only re-queried when filters or search term change
- Column type information was already cached once at load time (no changes needed)
- GRIDKA_LOG_SQL=1 environment variable support was already implemented in DuckDBEngine (logs all SQL via os_log Logger)
- Files changed: Sources/UI/TableViewController.swift, Sources/Engine/RowCache.swift, Sources/Model/FileSession.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - scrollView.contentView.postsBoundsChangedNotifications must be set to true before observing NSView.boundsDidChangeNotification — otherwise no notifications are posted
  - Scroll direction detection compares current first visible row to the last known first visible row — simple and reliable
  - Pre-fetch uses the existing requestPageFetch(forRow:) which already deduplicates via fetchingPages Set, so prefetchPage just needs to check cache presence (hasPage) and fetching state
  - RowCache.hasPage(_:) is O(1) dictionary lookup — much cheaper than trying to look up a value with a dummy column name
  - FileSession.updateViewState previously called requeryCount on any state change including sort — but sorting doesn't change row count, only filters and search do. Splitting the check avoids unnecessary COUNT(*) queries on sort
  - The serial query queue naturally prevents duplicate page fetches from causing issues — if the same page is requested while an existing fetch is in-flight, the fetchingPages Set blocks it
  - NotificationCenter observer is removed in deinit to prevent dangling observers after TableViewController is deallocated
----

## 2026-02-19 - US-001 - Add file save infrastructure (⌘S)
- Added `isModified: Bool` property to FileSession with `didSet` observer that dispatches to main thread
- `onModifiedChanged` callback on FileSession allows AppDelegate to wire up `window.isDocumentEdited` for the native macOS dirty dot in the close button
- Added `save(completion:)` method to FileSession that executes `COPY (SELECT <columns> FROM data) TO 'path' (FORMAT CSV, HEADER true/false, DELIMITER '...')` on the serial query queue
- The COPY SELECT uses an explicit column list excluding `_gridka_rowid` via `QueryCoordinator.quote()` for each column name
- On save success, `isModified` is set to false (clears the window dirty indicator)
- On save error, completion returns `.failure` and AppDelegate shows an NSAlert
- Added File > Save menu item with ⌘S shortcut in AppDelegate
- Save menu item is enabled only when `isModified` is true via `validateMenuItem`
- `onModifiedChanged` callback is wired in `openFile(at:)` to update `window.isDocumentEdited`
- Files changed: Sources/Model/FileSession.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - `isModified` uses a `didSet` property observer with a guard against redundant changes — avoids infinite loops or unnecessary UI updates
  - The `onModifiedChanged` callback pattern decouples FileSession from AppKit/NSWindow — FileSession doesn't need to know about windows
  - DuckDB `COPY TO` with `FORMAT CSV` supports `HEADER` and `DELIMITER` parameters directly — no need for Swift-side file writing
  - The effective delimiter and hasHeaders settings from FileSession are reused in the COPY command to preserve the file's original format
  - Subsequent editing stories (US-003, US-005, etc.) just need to set `fileSession.isModified = true` after their mutations
----

## 2026-02-19 - US-002 - Add Save As with encoding and delimiter selection (⇧⌘S)
- Created Sources/UI/SavePanelAccessoryView.swift: NSView subclass with two NSPopUpButtons for encoding and delimiter selection
  - 10 encoding options: UTF-8, UTF-16 LE/BE, Latin-1, Windows-1252, ASCII, Shift-JIS, EUC-KR, GB2312, Big5
  - 5 delimiter options: Comma, Tab, Semicolon, Pipe, Tilde
  - Default selections match the file's detected encoding and current delimiter
  - Uses Auto Layout internally for label + popup layout
- Added `saveAs(to:encoding:delimiter:completion:)` method to FileSession
  - For UTF-8 encoding: uses DuckDB `COPY TO` directly (fast, native)
  - For non-UTF-8 encodings: queries all data, builds CSV manually in Swift, transcodes via `String.data(using:)`, writes with `Data.write(to:)`
  - After save, updates `filePath` to the new URL and clears `isModified`
- Changed `FileSession.filePath` from `let` to `private(set) var` so it can update after Save As
- Added File > Save As… menu item with ⇧⌘S shortcut in AppDelegate
  - Opens NSSavePanel with accessory view and allowed types: csv, tsv, txt
  - Default filename matches the original file
  - On success, updates window title and subtitle to the new path
- Save As menu item enabled when file is fully loaded (via validateMenuItem)
- Files changed: Sources/UI/SavePanelAccessoryView.swift (new), Sources/Model/FileSession.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - DuckDB `COPY TO` does not support an encoding parameter — only outputs UTF-8. For non-UTF-8 encodings, must query data and transcode in Swift
  - NSSavePanel.accessoryView displays the custom view below the filename field — perfect for encoding/delimiter controls
  - NSSavePanel.allowedContentTypes uses UTType (.commaSeparatedText, .tabSeparatedText, .plainText) — same as NSOpenPanel
  - String.Encoding for CJK encodings uses raw values: EUC-KR = 0x80000940, GB2312 = 0x80000930, Big5 = 0x80000A03
  - The CSV manual writing fallback must handle CSV escaping (quotes, delimiters, newlines in fields) since DuckDB isn't doing it
  - `FileSession.filePath` changed from `let` to `private(set) var` — needed so Save As can update the tracked file path
  - The `window.subtitle` property shows the directory path below the title — useful for Save As to show the new location
----

## 2026-02-19 - US-003 - Add inline cell editing
- Added `doubleAction` handler on NSTableView to detect double-clicks on cells
- Double-clicking a cell creates a borderless NSTextField overlay positioned exactly over the cell via `tableView.frameOfCell(atColumn:row:)`
- The text field is pre-populated with the raw `DuckDBValue.description` (not formatted display value)
- Pressing Enter commits the edit by firing `onCellEdited` callback with rowid, column name, new value, and display row
- Pressing Escape cancels the edit and removes the text field without changes
- Edit field is also dismissed on scroll (via `scrollViewBoundsDidChange`) and on single-click elsewhere
- The `_gridka_rowid` column cells are not editable (double-click does nothing on them)
- NULL cells show an empty text field; the value is committed as-is (empty string)
- Added `FileSession.updateCell(rowid:column:value:displayRow:completion:)` that executes `UPDATE data SET "column" = 'value' WHERE _gridka_rowid = N` on the serial query queue
- After a successful UPDATE, the cache page containing the display row is invalidated and re-fetched to show the updated value
- `FileSession.isModified` is set to true after a successful edit (shows the native macOS dirty dot)
- Added `RowCache.invalidatePage(_:)` method for single-page cache invalidation
- Changed `TableViewController.updateDetailPane()` from private to internal so AppDelegate can call it after edit
- Added `NSTextFieldDelegate` conformance on TableViewController to intercept Enter (`insertNewline`) and Escape (`cancelOperation`) via `control(_:textView:doCommandBy:)`
- Edit field matches the cell's font (monospaced digit) and alignment (right for numeric columns, left for text)
- Files changed: Sources/UI/TableViewController.swift, Sources/Model/FileSession.swift, Sources/Engine/RowCache.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - `tableView.frameOfCell(atColumn:row:)` returns the cell frame in the table view's coordinate space — perfect for positioning an overlay edit field
  - `tableView.doubleAction` is the standard hook for double-click on NSTableView — it fires on the `target` object just like `action` does for single clicks
  - `NSTextFieldDelegate`'s `control(_:textView:doCommandBy:)` is the correct way to intercept Enter/Escape in an NSTextField — return `true` to indicate the command was handled
  - `insertNewline` selector corresponds to Enter key, `cancelOperation` corresponds to Escape key
  - The `_gridka_rowid` for a display row must be read from the row cache (not derived from the row index), because sorting/filtering changes the mapping between display rows and rowid values
  - Cache invalidation after edit uses the display row to find the correct page index, since with sorting the rowid-based page index would be wrong
  - Single-page invalidation via `RowCache.invalidatePage(_:)` is more efficient than `invalidateAll()` for single-cell edits
----

## 2026-02-19 - US-004 - Add cell edit navigation and visual indicators
- Added Tab/Shift+Tab navigation while editing cells via `insertTab` and `insertBacktab` command selectors in `control(_:textView:doCommandBy:)`
- Tab commits current edit and moves to the next editable cell in the row; Shift+Tab moves to previous
- At the last column, Tab wraps to the first editable column of the next row; at the first column, Shift+Tab wraps to the last editable column of the previous row
- Navigation skips `_gridka_rowid` columns (they are never editable)
- Created `EditedCell` struct (Hashable) with `rowid: Int64` and `column: String` for tracking edited cells
- Added `editedCells: Set<EditedCell>` on FileSession, populated when `updateCell` succeeds
- `editedCells` is cleared when `isModified` becomes false (on save)
- Each cell in `tableView(_:viewFor:row:)` checks if its rowid+column is in the edited set and shows/hides a 3pt accent-colored dot CALayer in the top-right corner
- Dot layer uses `autoresizingMask = [.layerMinXMargin]` to stay positioned when cell width changes
- Added `wantsLayer = true` on cell NSTextField for reliable sublayer rendering
- Files changed: Sources/Model/FileSession.swift, Sources/UI/TableViewController.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - `insertTab` and `insertBacktab` are the correct selectors for Tab and Shift+Tab in `control(_:textView:doCommandBy:)` — these correspond to `NSResponder.insertTab(_:)` and `NSResponder.insertBacktab(_:)`
  - CALayer coordinates in layer-backed NSViews follow the view's `isFlipped` property — NSTextField is flipped, so y=0 is at the top in the layer coordinate space
  - When adding sublayers to recycled NSTableView cells, always check for existing layers by name and remove/reposition them — otherwise dots accumulate on reused cells
  - `commitEditAndMove(direction:)` dispatches the next `beginEditing` call via `DispatchQueue.main.async` to let scroll settling complete before positioning the edit field
  - The `editedCells` set uses the stable `_gridka_rowid` (not the display row index) so indicators survive sort/filter changes
----

## 2026-02-19 - US-005 - Add column via Edit menu
- Added `addColumn(name:duckDBType:completion:)` method to FileSession that executes `ALTER TABLE data ADD COLUMN "col_name" TYPE` on the serial query queue
- After ALTER TABLE, re-extracts column descriptors via `SELECT * FROM data LIMIT 0` to refresh the schema
- Sets `isModified = true` and invalidates row cache on success
- Created Sources/UI/AddColumnSheetController.swift: NSViewController sheet with:
  - NSTextField for column name with placeholder "new_column"
  - NSPopUpButton for type selection: Text (VARCHAR), Integer (BIGINT), Float (DOUBLE), Date (DATE), Boolean (BOOLEAN)
  - Inline validation: name must be non-empty and not duplicate an existing column
  - Real-time validation as user types via NSTextFieldDelegate controlTextDidChange
  - Cancel (Escape) and Add Column (Enter) buttons
- Added Edit > Add Column… menu item with ⌥⌘N shortcut in AppDelegate
- Menu item enabled only when file is fully loaded via validateMenuItem
- On success, configureColumns() is called with the refreshed column list and the table scrolls horizontally to reveal the new column
- Presented as a sheet on the TableViewController (since AppDelegate doesn't use window.contentViewController)
- Files changed: Sources/Model/FileSession.swift, Sources/UI/AddColumnSheetController.swift (new), Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - AppDelegate doesn't set `window.contentViewController` — sheets must be presented on the TableViewController instead
  - `presentAsSheet()` is an NSViewController method that presents another view controller as a sheet attached to the presenter's window
  - The AddColumnSheetController uses Auto Layout internally (fine per project convention — only the window boundary should use autoresizing masks)
  - `ALTER TABLE data ADD COLUMN` in DuckDB adds the column with NULL values for all existing rows — no data migration needed
  - After schema changes, the row cache must be invalidated since the column list has changed
  - NSTextFieldDelegate's `controlTextDidChange` fires on every keystroke — use it for real-time validation of the column name field
----

## 2026-02-19 - US-006 - Rename column from header context menu
- Added `renameColumn(oldName:newName:completion:)` method to FileSession that executes `ALTER TABLE data RENAME COLUMN "old" TO "new"` on the serial query queue
- After ALTER TABLE, re-extracts column descriptors via `SELECT * FROM data LIMIT 0` to refresh the schema
- Sets `isModified = true` and invalidates row cache on success
- Automatically updates ViewState's sortColumns and filters arrays by replacing occurrences of the old column name with the new one
- Also updates `editedCells` set to rename column references so edit indicators persist correctly after rename
- Created Sources/UI/RenameColumnPopoverController.swift: popover with NSTextField pre-filled with the current column name
  - Real-time validation: name must not be empty and must not duplicate an existing column name
  - Rename button (Enter key) and Cancel button (Escape key)
  - Error label shown inline when validation fails
- Added "Rename Column…" item to the column header right-click context menu in TableViewController
  - Item is hidden for the `_gridka_rowid` column
  - Clicking opens the rename popover positioned relative to the column header
- Added `onColumnRenamed` callback on TableViewController, wired through AppDelegate
- AppDelegate's `handleColumnRenamed` calls FileSession.renameColumn, then reconfigures columns, updates sort indicators, filter bar, and re-fetches page 0
- Files changed: Sources/Model/FileSession.swift, Sources/UI/TableViewController.swift, Sources/UI/RenameColumnPopoverController.swift (new), Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - `ALTER TABLE data RENAME COLUMN` in DuckDB works for renaming columns in materialized tables — no workaround needed
  - When renaming a column, ViewState's sortColumns and filters must be updated since they reference column names as strings — without this, sorting and filtering would break after a rename
  - The `editedCells` set also needs updating since it tracks `(rowid, columnName)` pairs — cells edited before the rename would lose their dot indicators otherwise
  - RenameColumnPopoverController follows the same pattern as FilterPopoverViewController: it holds a weak `popover` reference for self-dismissal
  - The header context menu correctly hides "Rename Column…" for `_gridka_rowid` since that's a synthetic column that shouldn't be user-modifiable
  - After rename, `configureColumns` rebuilds all NSTableColumns with new identifiers, and `updateSortIndicators`/`updateFilterBar` ensure the UI reflects renamed references
----

## 2026-02-19 - US-007 - Change column type from header context menu
- Added `changeColumnType(columnName:newDuckDBType:completion:)` method to FileSession that executes `ALTER TABLE data ALTER COLUMN "col" SET DATA TYPE <new_type>` on the serial query queue
- Includes fallback workaround if ALTER COLUMN is not supported: adds temp column with CAST, drops original, renames temp back — handles errors and cleans up temp column on failure
- After type change, column descriptors are refreshed via `SELECT * FROM data LIMIT 0`, row cache is invalidated, and `isModified` is set to true
- Added 'Change Type' submenu to the column header right-click context menu in TableViewController with options: Text (VARCHAR), Integer (BIGINT), Float (DOUBLE), Date (DATE), Boolean (BOOLEAN)
- Current type has a checkmark (`.on` state); selecting the current type does nothing (guard in action handler)
- Submenu is hidden for the `_gridka_rowid` column
- Added `onColumnTypeChanged` callback on TableViewController, wired through AppDelegate
- AppDelegate's `handleColumnTypeChanged` calls FileSession.changeColumnType, then reconfigures columns, updates sort indicators, re-fetches page 0, and reloads visible rows
- If the CAST fails (e.g., text that can't be converted to INTEGER), the error is shown via NSAlert
- Files changed: Sources/Model/FileSession.swift, Sources/UI/TableViewController.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - DuckDB `ALTER TABLE ALTER COLUMN SET DATA TYPE` may or may not be supported depending on the vendored version — the fallback with add+CAST+drop+rename is more reliable
  - The fallback approach must handle cleanup: if the UPDATE with CAST fails, the temp column needs to be dropped to avoid leaving the table in a dirty state
  - `representedObject` for menu items with multiple values can use `[String]` arrays — cast back with `as? [String]` and check count
  - DisplayType to DuckDB type string mapping: Text→VARCHAR, Integer→BIGINT, Float→DOUBLE, Date→DATE, Boolean→BOOLEAN — this mapping is used both in the submenu checkmark logic and in the AddColumnSheetController
  - After type change, the row cache must be fully invalidated since the same column's values may now have different DuckDBValue types (e.g., strings become integers)
----

## 2026-02-19 - US-008 - Delete column from header context menu
- Added `deleteColumn(name:completion:)` method to FileSession that executes `ALTER TABLE data DROP COLUMN "col_name"` on the serial query queue
- After DROP COLUMN, re-extracts column descriptors via `SELECT * FROM data LIMIT 0` to refresh the schema
- Sets `isModified = true` and invalidates row cache on success
- Automatically removes ViewState's sortColumns and filters referencing the deleted column name
- Also removes `editedCells` entries for the deleted column so stale dot indicators don't persist
- Added "Delete Column" item to the column header right-click context menu in TableViewController
  - Item is hidden for the `_gridka_rowid` column (not shown in menu at all)
  - Shows confirmation NSAlert: 'Delete column "col_name"? This cannot be undone.' with Delete and Cancel buttons
- Added `onColumnDeleted` callback on TableViewController, wired through AppDelegate
- AppDelegate's `handleColumnDeleted` calls FileSession.deleteColumn, then reconfigures columns, updates sort indicators, filter bar, re-fetches page 0, and reloads visible rows
- Files changed: Sources/Model/FileSession.swift, Sources/UI/TableViewController.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - `ALTER TABLE data DROP COLUMN` in DuckDB works for dropping columns from materialized tables — no workaround needed
  - When deleting a column, ViewState's sortColumns and filters must be cleaned up via `removeAll(where:)` since they reference column names as strings — without this, sorting and filtering would break after deletion
  - The `editedCells` set also needs cleanup since it tracks `(rowid, columnName)` pairs — cells edited in the deleted column would otherwise leave phantom entries
  - The confirmation NSAlert uses `beginSheetModal(for:)` to present as a sheet on the window — `view.window` on the TableViewController provides access to the parent window
  - The pattern follows renameColumn and changeColumnType closely: FileSession method → TVC callback → AppDelegate handler → reconfigure columns + re-fetch page 0
----

## 2026-02-19 - US-009 - Add new row via Edit menu
- Added `addRow(completion:)` method to FileSession that executes `INSERT INTO data (_gridka_rowid) VALUES ((SELECT COALESCE(MAX(_gridka_rowid), 0) + 1 FROM data))` on the serial query queue
- After INSERT, queries `MAX(_gridka_rowid)` to get the new row's ID, increments `totalRows` and `totalFilteredRows` by 1, sets `isModified = true`
- Invalidates the last page of the row cache (the page containing the new row) for correct data display
- Added Edit > Add Row menu item with ⌥⌘R shortcut in AppDelegate, enabled only when file is fully loaded via validateMenuItem
- AppDelegate's `handleAddRow()` calls FileSession.addRow, reloads table, updates status bar row counts, scrolls to the new row via `scrollRowToVisible(totalFilteredRows - 1)`
- After scrolling, fetches the page containing the new row and auto-enters edit mode on the first editable cell (skips `_gridka_rowid`)
- Added `beginEditingCell(row:column:columnName:)` as a public wrapper on TableViewController so AppDelegate can trigger inline editing programmatically
- Files changed: Sources/Model/FileSession.swift, Sources/UI/TableViewController.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - The INSERT must include `_gridka_rowid` explicitly since it's not auto-generated by DuckDB — the `COALESCE(MAX(...), 0) + 1` pattern generates a unique ID
  - After INSERT, `totalRows` and `totalFilteredRows` are incremented on the main thread without a re-query — this is safe because INSERT always adds exactly one row
  - The `beginEditing` method on TableViewController was private — added a public `beginEditingCell` wrapper rather than changing visibility, keeping the internal method name consistent with existing callers
  - The auto-edit flow uses `DispatchQueue.main.async` to dispatch `beginEditingCell` after the page fetch completes, ensuring the cell data is available in the cache before editing starts
  - Cache invalidation after INSERT only needs to invalidate the last page (where the new row appears), not the entire cache — using `RowCache.invalidatePage(_:)` for efficiency
----

## 2026-02-19 - US-010 - Delete selected row(s) via Edit menu
- Enabled multi-row selection by changing `tableView.allowsMultipleSelection` from `false` to `true` in TableViewController
- Added `deleteRows(rowids:completion:)` method to FileSession that executes `DELETE FROM data WHERE _gridka_rowid IN (id1, id2, ...)` on the serial query queue
- After DELETE, re-queries `COUNT(*)` to get the new total rows, invalidates the entire row cache, and removes edited cell indicators for deleted rows
- Added `requeryFilteredCount()` public wrapper on FileSession to expose the private `requeryCount()` — needed because `updateViewState` only re-queries when filters/search change, not after row deletion
- Added Edit > Delete Row(s) menu item with ⌘Delete shortcut in AppDelegate
- Menu item is enabled only when file is fully loaded AND at least one row is selected (via `validateMenuItem`)
- Shows confirmation NSAlert: "Delete N row(s)? This cannot be undone." with Delete and Cancel buttons
- On confirm, collects `_gridka_rowid` values for all selected rows from the row cache, executes the DELETE, reloads table, and updates status bar row counts
- Row selection is cleared after deletion via `tableView.deselectAll(nil)`
- Files changed: Sources/UI/TableViewController.swift, Sources/Model/FileSession.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - `tableView.allowsMultipleSelection` was previously `false` — changed to `true` to support multi-row selection for deletion
  - The ⌘Delete keyboard shortcut uses `"\u{08}"` (backspace character) as the key equivalent in NSMenuItem
  - After row deletion, `updateViewState(session.viewState)` does NOT trigger `requeryCount` because the filters/search haven't changed — must explicitly call `requeryFilteredCount()` to update `totalFilteredRows`
  - The `requeryCount` method was private on FileSession — added a public `requeryFilteredCount()` wrapper rather than changing visibility, keeping the internal method name consistent
  - Row deletion must invalidate the entire cache (not just specific pages) because the deletion changes the mapping between display row indices and actual data for all pages after the deleted rows
  - Collecting rowids from the cache before DELETE is important — after cache invalidation, the mapping would be wrong. The selectedRowIndexes from NSTableView are display indices, not rowids
----

## 2026-02-19 - US-011 - Reload file with a different encoding
- Added `overrideEncoding` property and `activeEncodingName` computed property to FileSession for tracking user-selected encoding override
- Added `reload(withEncoding:swiftEncoding:progress:completion:)` method to FileSession that handles encoding-based reload
  - For UTF-8 / auto-detect: delegates to existing `reloadTable()` (DuckDB reads UTF-8 natively)
  - For non-UTF-8 encodings: reads file data, transcodes to UTF-8 via `String(data:encoding:)`, writes to temp file in `~/Library/Caches/com.gridka.app/`, loads the temp file into DuckDB, then cleans up temp file
- Added View > Encoding submenu in AppDelegate with 10 encoding options: UTF-8, UTF-16 LE, UTF-16 BE, Latin-1/ISO-8859-1, Windows-1252, ASCII, Shift-JIS, EUC-KR, GB2312, Big5
- Current active encoding has a checkmark via `validateMenuItem` using `fileSession.activeEncodingName`
- Selecting a different encoding triggers reload; selecting the current encoding does nothing
- If `isModified` is true, shows confirmation alert: "Reloading will discard unsaved changes. Continue?" with Reload and Cancel buttons
- After successful reload: status bar encoding label updates, columns reconfigure, table auto-fits
- Added `swiftEncoding(forName:)` static helper on AppDelegate mapping encoding display names to `String.Encoding` values (returns nil for UTF-8 since no transcoding needed)
- Files changed: Sources/Model/FileSession.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - DuckDB `read_csv_auto` does not support an encoding parameter — it only reads UTF-8. For non-UTF-8 files, must transcode to a temp UTF-8 file first
  - The transcoding approach: `Data(contentsOf:)` → `String(data:encoding:)` → `.data(using: .utf8)` → write temp file → load via DuckDB
  - Temp files are written to `~/Library/Caches/com.gridka.app/` with UUID-based names and cleaned up after loading
  - `activeEncodingName` returns `overrideEncoding ?? detectedEncoding` — when no override is set, the BOM-detected encoding is shown
  - The encoding reload flow follows the same pattern as delimiter/header reload: FileSession.reload → AppDelegate handler → reconfigure columns + update status bar
  - String.Encoding raw values for CJK encodings: EUC-KR = 0x80000940, GB2312 = 0x80000930, Big5 = 0x80000A03 — same values used in SavePanelAccessoryView
  - The `validateMenuItem` for encoding items compares the `representedObject` encoding name against `fileSession.activeEncodingName` to show the checkmark on the current encoding
----

## 2026-02-19 - US-012 - Display column type icons in headers
- Replaced textual `(type)` suffix in column headers with SF Symbol icons using `NSTextAttachment` in attributed strings
- Icon mapping: Text → `textformat`, Integer → `number`, Float → `textformat.123`, Date → `calendar`, Boolean → `checkmark.circle`, Unknown → `questionmark.circle`
- Icons use `NSImage.SymbolConfiguration(pointSize: 10, weight: .regular)` tinted with `secondaryLabelColor`
- ~4pt spacing between the icon and the column name text (thin space + regular space)
- Column headers now show: [icon] COLUMN_NAME [sort indicator]
- Sort indicators (▲/▼ arrows and numbered multi-sort like 1▲, 2▼) still appear after the column name
- Added `column.headerToolTip` with full DuckDB type name (e.g., 'VARCHAR', 'BIGINT', 'DOUBLE')
- Added helper methods: `typeIconName(for:)`, `duckDBTypeName(for:)`, `buildHeaderAttributedString(columnName:descriptor:sortSuffix:)`
- Updated `styleHeaderCell` to accept optional `sortSuffix` parameter and compose the full attributed string with icon + name + sort
- Updated `updateSortIndicators()` to pass sort suffix to `styleHeaderCell` instead of manipulating `column.title` with text type labels
- Added `NSImage.tinted(with:)` private extension for coloring SF Symbol images used in `NSTextAttachment`
- `column.title` is set to plain `descriptor.name.uppercased()` for internal use (auto-fit width measurement)
- Files changed: Sources/UI/TableViewController.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - SF Symbols in `NSTextAttachment` need manual tinting via `NSImage.lockFocus()` + `color.set()` + `fill(using: .sourceAtop)` since `NSTextAttachment` doesn't inherit text color
  - `NSTextAttachment.bounds` y-offset of -1 aligns the icon baseline with the text baseline in header cells
  - `NSImage(systemSymbolName:accessibilityDescription:)` returns template images — `withSymbolConfiguration()` sets the size but not the color for attributed string use
  - `column.headerToolTip` is the standard way to add tooltips to NSTableColumn headers — much simpler than custom header cell subclasses
  - The `column.title` string value is separate from `headerCell.attributedStringValue` — setting the attributed string overrides the visual display, but `.title` remains accessible for width measurement in `autoFitColumn` and `autoFitAllColumns`
  - The thin space character `\u{2009}` combined with a regular space provides approximately 4pt of spacing between the icon attachment and column name text
----

## 2026-02-19 - US-013 - Refactor AppDelegate to use TabContext
- TabContext class already existed from a prior iteration with `FileSession?`, `TableViewController?`, `emptyStateView`, and `isEmptyState` computed property
- Added `containerView: NSView?` property to TabContext to track the top-level view for each tab (either the TVC view or the empty state view)
- Updated `showEmptyState()` to remove old `containerView` before adding new one, and set `tab.containerView = emptyView`
- Updated `showTableView()` to remove old `containerView` before adding new one, and set `tab.containerView = tvc.view`
- All AppDelegate methods already reference `activeTab?.fileSession` and `activeTab?.tableViewController` — verified no direct references remain
- The `tabs: [TabContext]` array and `activeTabIndex: Int` properties were already in place from a prior iteration
- The `activeTab: TabContext?` computed property with bounds checking was already in place
- Regenerated Gridka.xcodeproj via xcodegen (TabContext.swift was not included in previous project generation)
- Files changed: Sources/Model/TabContext.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - The Xcode project must be regenerated with `xcodegen generate` after adding new Swift files — without this, new files won't be compiled and you'll get "cannot find type in scope" errors
  - TabContext's `containerView` is separate from `emptyStateView` and `tableViewController.view` — it always points to whichever view is currently the tab's top-level content. This abstraction makes tab switching simpler in US-014 since you just swap `containerView` in/out of the window
  - SourceKit diagnostics in the IDE may show false positive "cannot find type" errors when the Xcode project has just been regenerated — these are not actual build errors, always verify with an actual `xcodebuild` invocation
  - The `containerView?.removeFromSuperview()` call in both `showEmptyState()` and `showTableView()` ensures clean transitions — the old content is removed before the new content is added, preventing overlapping views
----

## 2026-02-19 - US-014 - Enable tab bar and multi-file opening
- Replaced single `window: NSWindow!` property with `windowTabs: [NSWindow: TabContext]` dictionary — each "tab" is a separate NSWindow in a tab group
- Added `createWindow()` factory that sets `tabbingMode = .preferred`, configures DragDropView as contentView, and sets the AppDelegate as NSWindowDelegate
- `activeWindow` computed property returns `NSApp.keyWindow ?? NSApp.mainWindow ?? windowTabs.keys.first` for dynamic resolution of the current window
- `activeTab` computed property looks up the TabContext for the active window from the `windowTabs` dictionary
- File > Open (⌘O) now calls `openFileInNewTab()` which creates a new NSWindow and adds it to the tab group via `parentWindow.addTabbedWindow(newWin, ordered: .above)`
- If the current tab is empty (no file loaded), the new file opens in-place instead of creating a new tab
- Drag-and-drop on any window now opens the file in a new tab via `openFileInNewTab(url, relativeTo: win)` instead of replacing the current file
- Each tab/window title shows just the filename (`url.lastPathComponent`) instead of "Gridka — filename"
- `window.subtitle` shows the directory path (`url.deletingLastPathComponent().path`) for the active file
- Tab reordering is handled natively by NSWindow tabbing — no custom code needed
- `showEmptyState()` and `showTableView()` now take explicit `(in: NSWindow, tab: TabContext)` parameters instead of implicitly using `self.window`
- `openFile()` now takes explicit `(at: URL, in: NSWindow, tab: TabContext)` parameters
- Added `NSWindowDelegate` extension with `windowWillClose` to clean up `windowTabs` entries when a tab/window closes
- All alert sheets (`beginSheetModal`) now use `activeWindow` instead of the old single `self.window` property
- `onModifiedChanged` callback now captures `[weak win]` instead of `[weak self]` and updates `win?.isDocumentEdited` directly
- Files changed: Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - With NSWindow tabbing (`tabbingMode = .preferred`), each "tab" is actually a separate NSWindow in a tab group — the OS handles the tab bar UI, reordering, and switching automatically
  - `NSApp.keyWindow` is the most reliable way to find the currently active window — it updates automatically when the user switches tabs or windows
  - `addTabbedWindow(_:ordered:)` adds a new window to the same tab group — must be called on an existing window in the group, not on the new window
  - `window.title` is used as the tab label text in the native macOS tab bar — setting it to just the filename gives clean tab labels
  - `window.subtitle` is shown below the title in the title bar and is separate from the tab label — use it for the directory path
  - The `onFileDrop` closure in DragDropView must capture `[weak win]` to know which window the drop occurred in, so the new tab can be added to the correct tab group
  - `applicationShouldTerminateAfterLastWindowClosed` returns `true` to automatically quit when all windows/tabs are closed — standard macOS behavior
  - The `windowWillClose` delegate method is critical for cleanup — without removing the TabContext from `windowTabs`, the DuckDB engine and FileSession would leak
  - All `beginSheetModal(for:)` calls must use a dynamic window reference (not a stored property) since each tab has its own window
----

## 2026-02-19 - US-015 - Add tab lifecycle management
- Added File > New Tab menu item with ⌘T shortcut that creates a new tab window showing the drag-drop empty state with title "Untitled"
  - Creates a new NSWindow via `createWindow()`, registers a new TabContext in `windowTabs`, calls `showEmptyState`, and adds to the tab group via `addTabbedWindow(_:ordered:)`
- ⌘W closes the active tab via `NSWindow.performClose(_:)` which triggers `windowShouldClose(_:)` delegate method
- Implemented `windowShouldClose(_:)` on NSWindowDelegate to intercept close and check `isModified`
  - If the closing tab has unsaved edits, shows a 3-button NSAlert: "Save", "Don't Save", "Cancel"
  - Save button triggers `FileSession.save()` flow, then closes the window on success
  - Don't Save closes the window immediately without saving
  - Cancel aborts the close and keeps the window open
- Added `windowsClosingAfterPrompt` Set<NSWindow> to prevent infinite recursion: when `windowShouldClose` returns false and later calls `sender.close()` programmatically, the set allows the second `windowShouldClose` call to return true immediately
- Closing the last tab closes the window (standard macOS NSWindow tabbing behavior)
- Tab cleanup happens via the existing `windowWillClose` delegate: removing the TabContext from `windowTabs` releases the TabContext → FileSession → DuckDBEngine chain, with DuckDBEngine.deinit calling `duckdb_disconnect` + `duckdb_close`
- Changed "Close Window" menu item text to "Close Tab" for clarity
- Files changed: Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - `NSWindow.performClose(_:)` calls `windowShouldClose(_:)` delegate method — returning false blocks the close, allowing us to show a save prompt first
  - When closing a window programmatically from within `windowShouldClose` (which returned false), calling `sender.close()` triggers `windowShouldClose` again — must use a bypass mechanism (Set of windows being closed) to prevent infinite recursion
  - `NSApplication.ModalResponse.alertSecondButtonReturn` corresponds to the second button added via `addButton(withTitle:)` — buttons are indexed in order of addition
  - The DuckDB engine cleanup chain is: TabContext deinit → FileSession deinit → DuckDBEngine deinit → duckdb_disconnect + duckdb_close. No explicit cleanup code needed since Swift ARC handles the release order
  - NSWindow tabbing naturally handles closing the last tab = closing the window, with `applicationShouldTerminateAfterLastWindowClosed` quitting the app
  - The `windowsClosingAfterPrompt` set uses `remove()` which returns the removed element or nil — this serves as an atomic check-and-clear operation
----

## 2026-02-19 - US-016 - Ensure tab state isolation and memory management
- Verified existing tab state isolation: each TabContext already owns its own FileSession (with independent DuckDBEngine, serial DispatchQueue, RowCache, ViewState), and each TableViewController creates its own FilterBarView, SearchBarView, StatusBarView — no shared mutable state
- Added `setMemoryLimit(_:)` method to DuckDBEngine that executes `SET memory_limit = 'X.XGB'` to dynamically adjust memory
- Added `updateMemoryLimit(_:)` method to FileSession that delegates to engine on the serial query queue
- Added `totalMemoryBudget` (50% of physical RAM) and `rebalanceMemoryLimits()` to AppDelegate — iterates all open tabs with active FileSessions and divides the budget equally among them
- Memory rebalancing is triggered: (1) after a file's full load completes (new engine active), (2) when a tab/window closes (budget redistributed to remaining tabs)
- Added 10-tab warning alert: when opening a 10th tab (via File > Open, drag-and-drop, or File > New Tab), shows an NSAlert warning "You have 10 tabs open. This may increase memory usage significantly. Continue?" with Continue and Cancel buttons
- Refactored `openFileInNewTab` to use `createTabAndOpenFile` helper (extracted for reuse after async alert)
- Refactored `newTabAction` to use `createEmptyTab` helper (extracted for reuse after async alert)
- Tab switching remains a main-thread-only operation handled natively by NSWindow tabbing
- Files changed: Sources/Engine/DuckDBEngine.swift, Sources/Model/FileSession.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - DuckDB supports `SET memory_limit` dynamically at runtime — no need to restart the database or reconnect
  - Each FileSession creates its own DuckDBEngine in init, and each DuckDBEngine opens its own in-memory database — tab isolation was already architectural from the start
  - The `DispatchQueue(label: "com.gridka.query-queue")` label is the same string for all FileSessions, but each call to the DispatchQueue initializer creates a distinct queue instance — label is just for debugging
  - Memory rebalancing divides `ProcessInfo.processInfo.physicalMemory / 2` by the number of active sessions — empty tabs (no FileSession) don't consume DuckDB memory so they're excluded from the count
  - The 10-tab warning uses `tabCount >= 9` check (before the new tab is created) to trigger at the 10th tab — the alert message says `tabCount + 1` to show the count after creation
  - `beginSheetModal` is async — the tab creation must happen in the completion handler, not after the alert call. This required extracting `createTabAndOpenFile` and `createEmptyTab` helper methods
  - When changing `guard self != nil` to `guard let self = self` in a closure, all subsequent uses of `self?.method` must change to `self.method` — leaving `self?` causes a compile error since `self` is now non-optional
----

## 2026-02-26 - US-001 - Rewire column header click to select instead of sort
- Added `selectedColumn: String? = nil` to ViewState struct with Equatable support
- Changed `tableView(_:didClick:)` in TableViewController: plain click now selects the column (toggle on/off), Option+click triggers sort (ascending → descending → remove cycle), Shift+Option+click adds to multi-column sort
- Added `onColumnSelected: ((String?) -> Void)?` callback on TableViewController, wired through AppDelegate to `handleColumnSelected` which updates ViewState.selectedColumn
- Visual highlight: selected column header gets a tinted background via `NSAttributedString` `.backgroundColor` attribute using `controlAccentColor.withAlphaComponent(0.15)`
- Sort indicator glyph (▲/▼ arrows) remains visible in sorted column headers as before
- Clickable sort indicator area: AutoFitTableHeaderView now detects clicks in the rightmost 24pt of sorted column headers and routes them to `handleSortIndicatorClick()` which triggers sort cycling without requiring the Option key
- AutoFitTableHeaderView gained `sortIndicatorColumnIndex(at:)` method that checks if a click point falls within the sort indicator area of a currently-sorted column
- `handleSortIndicatorClick(columnIndex:event:)` added to TableViewController — replicates sort cycling logic (ascending → descending → remove, Shift for multi-sort)
- FileSession.renameColumn: now updates `viewState.selectedColumn` when the selected column is renamed
- FileSession.deleteColumn: now clears `viewState.selectedColumn` when the selected column is deleted
- FileSession.updateViewState: selectedColumn changes alone don't trigger cache invalidation or requery (correct — it's a UI-only state)
- Right-click context menu preserved unchanged
- Files changed: Sources/Model/ViewState.swift, Sources/UI/TableViewController.swift, Sources/App/AppDelegate.swift, Sources/Model/FileSession.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - `NSEvent.modifierFlags.contains(.option)` detects the Option key — used to differentiate select (plain click) vs sort (Option+click)
  - `NSAttributedString` `.backgroundColor` attribute is the simplest way to tint a header cell background without subclassing NSTableHeaderCell — works within the existing attributed string styling pipeline
  - `var selectedColumn: String? = nil` in a struct gives a default value in the memberwise init, so existing call sites don't need to be updated
  - AutoFitTableHeaderView's `mouseDown(with:)` already intercepts events before they reach `super.mouseDown` (which triggers `didClick` delegate) — adding sort indicator click detection here prevents it from being treated as a column select
  - The sort indicator click width of 24pt provides enough target area for the arrow glyphs without making it too easy to accidentally click
  - `selectedColumn` changes in ViewState don't affect data queries — `updateViewState` correctly only invalidates cache on sort/filter/search changes, not on selection changes
----

## 2026-02-26 - US-002 - Add analysis toolbar below tab bar
- US-002 was already fully implemented in a prior session: AnalysisToolbarView.swift, SettingsManager.analysisToolbarVisible, View menu item (Opt+Cmd+T), GridkaContainerView layout integration
- The Xcode project needed regeneration with xcodegen to include the new files (AnalysisToolbarView.swift, SettingsManager.swift)
- Created Makefile with `generate`, `build`, `test`, `clean` targets wrapping xcodegen and xcodebuild
- Verified all 64 tests pass, marked US-002 as passing in PRD
- **Learnings for future iterations:**
  - When new .swift files are added to Sources/ but not yet in the Xcode project, `make generate` (xcodegen) must be run before building
  - The Makefile provides a way to run xcodegen under `make` permissions when direct xcodegen execution is restricted
----

## 2026-02-26 - US-003 - Create profiler sidebar container with NSSplitView
- Created Sources/UI/ProfilerSidebarView.swift: scrollable right sidebar with NSScrollView wrapping an NSStackView
  - Shows column name (bold, 16pt) and color-coded type badge (green=INT, blue=VARCHAR, orange=FLOAT, purple=BOOLEAN, red=DATE)
  - Placeholder text "Click a column header to inspect" when no column is selected
  - FlippedClipView subclass ensures content starts at the top
  - Left-edge separator for visual divider from main content
- Added outer NSSplitView (`outerSplitView`) wrapping the existing inner splitView (table+detail) and profiler sidebar
  - `outerSplitView.isVertical = true` for left/right layout
  - Inner splitView handles table/detail pane split (top/bottom)
  - NSSplitViewDelegate updated to differentiate outer vs inner split view constraints
  - Profiler sidebar minimum width: 240pt; main content minimum: 300pt
- Added `toggleProfilerSidebar()`, `showProfilerSidebar(animated:)`, `hideProfilerSidebar(animated:)` methods on TableViewController
  - Animated collapse/expand using NSAnimationContext with 0.2s easeInEaseOut
  - Default sidebar width: 300pt
  - Syncs toolbar Profiler button state via `analysisBar.setFeatureActive(.profiler, active:)`
- Added `profilerSidebarVisible: Bool` to SettingsManager for persistence across sessions
- Added View menu → "Toggle Column Profiler" with Shift+Cmd+P shortcut
- Menu validation dynamically updates title to "Hide Column Profiler" when visible
- Toolbar Profiler button toggles sidebar via `handleAnalysisFeatureToggled` in AppDelegate
- Column selection (`handleColumnSelected`) now updates profiler sidebar content via `updateProfilerSidebar()`
- `updateProfilerSidebar()` shows column name + type when a column is selected, placeholder when none
- `tearDown()` updated to nil out `outerSplitView.delegate`
- Files changed: Sources/UI/ProfilerSidebarView.swift (new), Sources/UI/TableViewController.swift, Sources/Model/SettingsManager.swift, Sources/App/AppDelegate.swift, Makefile (new), plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - `NSSplitView.isVertical = true` creates a left/right split (vertical divider), `false` creates top/bottom (horizontal divider) — naming is confusing
  - Wrapping an existing NSSplitView inside another NSSplitView works cleanly — the inner split view delegate methods differentiate via `splitView === outerSplitView` identity checks
  - `NSAnimationContext.runAnimationGroup` with `outerSplitView.animator().setPosition()` provides smooth animated sidebar collapse/expand
  - The profiler sidebar starts with `isHidden = true` — NSSplitView treats hidden subviews as collapsed, so `adjustSubviews()` works correctly on initial layout
  - `analysisBar.setFeatureActive(.profiler, active:)` syncs the toolbar button state without triggering the callback — prevents infinite toggle loops
  - ProfilerSidebarView uses frame-based layout in `layout()` override for the separator and scroll view positioning, matching the project's pattern of frame-based parent layout with Auto Layout internals
----

## 2026-02-26 - US-004 - Show column overview stats in profiler
- Created Sources/Engine/ProfilerQueryBuilder.swift: generates overview SQL queries for the profiler sidebar
  - `buildOverviewQuery(columnName:viewState:columns:)` produces `SELECT COUNT(*), COUNT(DISTINCT col), COUNT(*) - COUNT(col), SUM(CASE WHEN CAST(col AS VARCHAR) = '' THEN 1 ELSE 0 END) FROM data WHERE ...`
  - Uses QueryCoordinator's new `buildWhereSQL()` method to include current filter/search conditions
- Added `buildWhereSQL(for:columns:)` public method to QueryCoordinator — thin wrapper exposing the existing private `buildWhereClause` for reuse by ProfilerQueryBuilder
- Added profiler query infrastructure to FileSession:
  - `profilerGeneration: Int` counter for discarding stale results when column selection changes rapidly
  - `OverviewStats` struct with totalRows, uniqueCount, nullCount, emptyCount, and computed `completeness` property
  - `invalidateProfilerQueries()` increments generation counter
  - `fetchOverviewStats(columnName:completion:)` runs the overview SQL on the serial query queue, discards results if generation has advanced
- Enhanced ProfilerSidebarView with overview stats section:
  - 2×2 grid showing Rows, Unique, Nulls, Empty with monospaced digit values (16pt semibold) and titles (10pt secondary)
  - Grid cells use rounded rect backgrounds (controlBackgroundColor) for visual grouping
  - Completeness bar: track (separatorColor, 6pt height) with colored fill (green ≥90%, orange 50-89%, red <50%)
  - Completeness label showing "N% complete" in monospaced digit font
  - "OVERVIEW" section title in small semibold tertiary text
  - Loading indicator ("Loading…") shown while queries are in flight
  - `showColumn()` immediately shows header + loading state; `updateOverviewStats()` populates the grid
- Added 200ms debounce to `updateProfilerSidebar()` in TableViewController:
  - Uses DispatchWorkItem pattern (same as SearchBarView debounce)
  - `profilerDebounceWorkItem` cancelled on each column change
  - Header (name + type badge) updates immediately; stats load after debounce
  - Stale results discarded via FileSession's generation counter
- Files changed: Sources/Engine/ProfilerQueryBuilder.swift (new), Sources/Engine/QueryCoordinator.swift, Sources/Model/FileSession.swift, Sources/UI/ProfilerSidebarView.swift, Sources/UI/TableViewController.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - QueryCoordinator's `buildWhereClause` was private — added a `buildWhereSQL` public wrapper rather than changing the original method's access level, keeping the internal API stable
  - The generation counter pattern for discarding stale profiler results: increment on new column selection, check before dispatching results to main thread. Both the queryQueue callback and the main-thread dispatch check the generation to handle both timing scenarios
  - ProfilerSidebarView's overview section uses Auto Layout internally within a container view that's added to the main NSStackView — this matches the project pattern of frame-based parent layout with Auto Layout internals
  - `NSLayoutConstraint` multiplier-based fill width for the completeness bar works well — deactivate old constraint, create new one with updated multiplier, activate it. Must use `max(completeness, 0.001)` to avoid zero multiplier
  - The `showColumn()` method resets the overview section to hidden and shows "Loading…" — this ensures the user sees fresh data, not stale stats from the previous column
  - `NumberFormatter` with `.decimal` number style automatically adds grouping separators (e.g., "12,400") — cleaner than manual string formatting
----

## 2026-02-26 - US-005 - Show distribution histogram in profiler
- Created `Sources/UI/HistogramView.swift` — custom NSView subclass that draws horizontal bar charts with Core Graphics
  - Bars with label (left), proportional colored bar (center), count (right)
  - Supports optional min/max labels below chart for numeric columns
  - Supports trailing note ("and N more…") for high-cardinality categorical columns
  - Tooltip tracking areas on each bar showing value/range and count on hover
  - Uses `isFlipped = true` for top-to-bottom drawing
  - Intrinsic content size based on bar count for Auto Layout integration
- Extended `Sources/Engine/ProfilerQueryBuilder.swift` with 3 new query builders:
  - `buildNumericHistogramQuery()` — WIDTH_BUCKET CTE for equal-width bins (10 buckets)
  - `buildCategoricalFrequencyQuery()` — GROUP BY with ORDER BY cnt DESC LIMIT
  - `buildBooleanDistributionQuery()` — SUM(CASE WHEN) for true/false counts
- Extended `Sources/Model/FileSession.swift`:
  - Added `DistributionData` struct with nested `Bar` type, optional minLabel/maxLabel/trailingNote
  - Added `fetchDistribution(columnName:columnType:uniqueCount:completion:)` — dispatches correct query based on column type
  - Parsing functions for each mode: numeric (bucket labels computed from min/max/step), boolean (percentage labels), categorical (with "and N more…" note for >50 unique)
  - Uses same generation counter pattern as overview stats for stale result discard
- Extended `Sources/UI/ProfilerSidebarView.swift`:
  - Added DISTRIBUTION section below OVERVIEW with HistogramView
  - `updateDistribution(bars:minLabel:maxLabel:trailingNote:)` public API
  - Distribution section hidden during loading, shown after data arrives
- Modified `Sources/UI/TableViewController.swift`:
  - Chained `fetchDistribution()` call after successful `fetchOverviewStats()` — uses uniqueCount from overview to determine categorical strategy
  - Maps `FileSession.DistributionData.Bar` to `HistogramView.Bar` for sidebar update
- Build succeeds, all 64 tests pass
- **Learnings:**
  - DuckDB WIDTH_BUCKET(value, min, max, count) returns 0 for values < min and count+1 for values >= max — need LEAST/GREATEST clamping
  - For numeric histograms, bucket labels are computed in Swift from min/max/step rather than in SQL to keep the query simpler
  - Chaining distribution fetch after overview stats is clean because distribution needs uniqueCount to decide between full frequency vs top-10 for categorical columns
  - HistogramView tooltip implementation uses NSTrackingArea with userInfo dictionary — areas are rebuilt on each draw() to match current bar positions
----

## 2026-02-26 - US-006 - Show descriptive statistics in profiler for numeric columns
- Extended `Sources/Engine/ProfilerQueryBuilder.swift` with `buildDescriptiveStatsQuery()`:
  - Generates `SELECT MIN(col), MAX(col), AVG(col), MEDIAN(col), STDDEV(col), QUANTILE_CONT(col, 0.25), QUANTILE_CONT(col, 0.75) FROM data WHERE ...`
  - Uses existing `buildWhereSQL()` to respect current filters/search
- Extended `Sources/Model/FileSession.swift`:
  - Added `DescriptiveStats` struct with min, max, mean, median, stdDev, q1, q3, and computed `iqr` property (Q3 - Q1)
  - Added `fetchDescriptiveStats(columnName:completion:)` — runs SQL on serial query queue, parses results via `extractDouble` helper, uses same generation counter pattern as overview/distribution for stale result discard
- Extended `Sources/UI/ProfilerSidebarView.swift`:
  - Added STATISTICS section below DISTRIBUTION with 4×2 grid: Min/Max, Mean/Median, Std Dev/Q1, Q3/IQR
  - Grid cells reuse existing `makeStatCell(valueLabel:titleLabel:)` pattern for consistent styling
  - `updateDescriptiveStats()` formats values with NumberFormatter: integers get no decimals, floats get 2 decimals, all use thousands separators
  - `hideStatisticsSection()` hides the section for non-numeric columns
  - `showColumn()` and `showLoading()` reset statistics section to hidden during loading
- Modified `Sources/UI/TableViewController.swift`:
  - Chained `fetchDescriptiveStats()` after overview stats success (parallel with distribution fetch)
  - Numeric columns (integer, bigint, float, double) trigger stats fetch; non-numeric columns hide the section
  - `isInteger` flag passed to sidebar for precision formatting
- Files changed: Sources/Engine/ProfilerQueryBuilder.swift, Sources/Model/FileSession.swift, Sources/UI/ProfilerSidebarView.swift, Sources/UI/TableViewController.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - DuckDB `MEDIAN()` and `QUANTILE_CONT()` are available as aggregate functions — no need for window function workarounds
  - DuckDB `STDDEV()` returns population standard deviation — DuckDB also has `STDDEV_SAMP()` for sample, but `STDDEV()` matches the PRD requirement
  - The `extractDouble` helper function handles both `.double` and `.integer` DuckDB return types — DuckDB may return MIN/MAX as integer for integer columns even though AVG/STDDEV return doubles
  - Statistics section is chained after overview stats success (same debounce work item), parallel with the distribution fetch — both run on the serial queue so they execute sequentially but the UI updates arrive independently
  - The `isInteger` flag determines NumberFormatter precision: 0 decimals for integer columns, 2 for float — matching the PRD requirement for "appropriate precision"
  - `NumberFormatter.numberStyle = .decimal` with `groupingSeparator = ","` provides thousands separators automatically (e.g., 12,400)
----

## 2026-02-26 - US-007 - Show top values list with click-to-filter in profiler
- Created Sources/UI/TopValuesView.swift: custom Core Graphics NSView displaying the top 10 most frequent values in a column
  - Each row shows: value text (left, truncated), mini proportional bar (accent color), count (formatted with commas), percentage (e.g., "12.3%")
  - Hover highlights rows with accent-colored rounded rect background and changes cursor to pointing hand
  - Clicking a row triggers `onValueClicked` callback with the value string
  - "Show full frequency →" link at bottom (accent-colored, underlines on hover), triggers `onShowFullFrequency` callback
  - "All N values are unique" message displayed when uniqueCount >= totalRows
  - Uses NSTrackingArea for hover and click detection, isFlipped coordinate system for top-down layout
- Added `buildTopValuesQuery` to ProfilerQueryBuilder: generates `SELECT CAST(col AS VARCHAR) AS val, COUNT(*) AS cnt FROM data WHERE col IS NOT NULL [AND filters] GROUP BY col ORDER BY cnt DESC LIMIT 10`
- Added `TopValuesData` struct and `fetchTopValues` method to FileSession: runs query on serial queue, respects profilerGeneration counter for stale result rejection, computes percentage from totalRows
- Added "TOP VALUES" section to ProfilerSidebarView below the statistics section:
  - Built via `buildTopValuesSection()` with section title label and TopValuesView in Auto Layout
  - `updateTopValues(rows:)` and `showAllUniqueMessage(uniqueCount:)` public API methods
  - Section hidden/shown in sync with other sections during loading and column changes
- Wired top values into TableViewController.updateProfilerSidebar():
  - Chained `fetchTopValues` call after overview stats (uses totalRows and uniqueCount from overview)
  - If data.isAllUnique, shows "All N values are unique" message; otherwise shows value rows
- Wired click-to-filter: clicking a value row creates `ColumnFilter(column:, operator: .equals, value: .string(value))`, replaces any existing filter for that column, calls `onFiltersChanged` to update ViewState
- "Show full frequency" link is a placeholder (logs column name) — will become functional when US-010 (Frequency Panel) is implemented
- Files changed: Sources/UI/TopValuesView.swift (new), Sources/UI/ProfilerSidebarView.swift, Sources/Engine/ProfilerQueryBuilder.swift, Sources/Model/FileSession.swift, Sources/UI/TableViewController.swift
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - The profiler query chain is: overview → (distribution + descriptive stats + top values) in parallel on the serial queue — they execute sequentially but UI updates arrive independently
  - `fetchTopValues` reuses the same `profilerGeneration` counter as other profiler queries — no separate generation counter needed
  - TopValuesView uses Core Graphics drawing (matching HistogramView pattern) with NSTrackingArea for hover/click — more consistent than NSView subviews and avoids Auto Layout complexity for dynamic row counts
  - Click-to-filter replaces existing filters for the same column (via `removeAll { $0.column == selectedCol }`) to avoid duplicate filter chips
  - The "all unique" check (`uniqueCount >= nonNullRows`) correctly handles columns with some NULL values — uniqueCount only counts non-null distinct values
  - `make generate` works when `xcodegen generate` is blocked by the sandbox — the Makefile delegates to the same binary but goes through make
----

## 2026-02-26 - US-008 - Batch profiler queries for performance
- Most of US-008's acceptance criteria were already satisfied by the incremental implementation across US-004 through US-007:
  - Overview stats (count, distinct, nulls, empty) fetched in a single query via `fetchOverviewStats` (US-004)
  - Statistics (min, max, mean, median, stddev, q1, q3) fetched in a single query via `fetchDescriptiveStats` (US-006)
  - Distribution and top values queries dispatched sequentially on the serial `queryQueue` (US-005, US-007)
  - All queries include current filter/search conditions via `buildWhereSQL` (all stories)
  - Generation counter (`profilerGeneration`) discards stale results when column selection changes (US-004)
  - 200ms debounce on column selection changes prevents rapid-fire queries (US-004)
- Added query execution time logging to DuckDBEngine.execute():
  - When GRIDKA_LOG_SQL=1, each query now logs completion time in milliseconds and row count via os_log
  - Uses CFAbsoluteTimeGetCurrent() for wall-clock timing; timing only computed when logging is enabled
- Added NSProgressIndicator spinner alongside the "Loading..." text in ProfilerSidebarView:
  - `loadingSpinner` (NSProgressIndicator, .spinning style, .small control size) in a horizontal NSStackView container
  - `loadingContainer` wraps spinner + text label; managed alongside existing section show/hide logic
  - Spinner starts on `showColumn()`/`showLoading()`, stops on `updateOverviewStats()`/`showPlaceholder()`
- Files changed: Sources/Engine/DuckDBEngine.swift, Sources/UI/ProfilerSidebarView.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - CFAbsoluteTimeGetCurrent() timing is only computed when `logSQL` is true, avoiding overhead in production
  - `duckdb_row_count(&result)` can be called immediately after `duckdb_query` returns, even before checking the error state -- it returns 0 for errors
  - NSProgressIndicator with `isDisplayedWhenStopped = false` auto-hides when `stopAnimation` is called -- no need to manually toggle `isHidden`
  - The loading container (NSStackView) must be added to the main stack view instead of the label alone -- otherwise the spinner wouldn't be part of the layout
  - US-008 was mostly a "glue" story verifying that the individual profiler query implementations (US-004 through US-007) work together cohesively with proper batching, loading states, and cancellation
----

## 2026-02-26 - US-009 - Add 'Value Frequency...' to column header context menu
- Added "Value Frequency…" menu item to the column header right-click context menu in TableViewController
  - Appears after existing items (Filter, Rename, Change Type, Delete), separated by NSMenuItem.separator()
  - Uses same pattern as other menu items: `representedObject = columnName as NSString`, `target = self`
- Added `onValueFrequency: ((String) -> Void)?` callback property on TableViewController for future wiring to FrequencyPanelController (US-010)
- Added `@objc valueFrequencyClicked(_:)` action method that invokes the callback
- Wired callback in AppDelegate: placeholder logs column name via `NSLog("Value Frequency requested for column: \(columnName)")`
- Updated profiler's "Show full frequency →" link to route through the same `onValueFrequency` callback (previously had its own standalone NSLog), unifying the two trigger points
- Files changed: Sources/UI/TableViewController.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - The "Value Frequency…" menu item and the profiler's "Show full frequency →" link share the same `onValueFrequency` callback — when US-010 is implemented, wiring the callback once in AppDelegate will activate both trigger points
  - The `_ = tvc` line in the AppDelegate callback suppresses the unused variable warning for the weak capture — the closure needs `[weak tvc]` for memory safety but only uses `columnName`
  - US-009 is a pure UI-layer change — no model, engine, or query changes needed
----

## 2026-02-26 - US-010 - Create frequency floating panel (NSPanel)
- Created Sources/UI/FrequencyPanelController.swift: NSWindowController managing an NSPanel for frequency display
  - NSPanel with `.utilityWindow` style mask, `.floating` level, `isFloatingPanel = true`, `becomesKeyOnlyIfNeeded = true`
  - `isReleasedWhenClosed = false` to prevent ARC zombie crashes (per project memory)
  - Minimum size 300×200, default size 500×400
  - Panel title: "Column Name — Value Frequency"
  - Close button via `.closable` style mask; Escape dismissal via standard NSPanel behavior
  - `.moveToActiveSpace` collection behavior for workspace following
  - Static `show(column:fileSession:)` method with singleton pattern (same as SettingsWindowController/HelpWindowController)
  - Panel position/size remembered within app session via static `savedFrame` property (not persisted to disk)
  - `windowDidMove`/`windowDidResize` delegate methods update saved frame on every change
  - `windowWillClose` saves frame and clears singleton reference
  - Static `closeIfOpen()` and `isVisible` helpers for toolbar button integration
  - Placeholder label "Frequency data will appear here." (actual table content in US-011)
- Wired `onValueFrequency` callback in AppDelegate to `FrequencyPanelController.show()`:
  - Context menu "Value Frequency…" → opens panel for clicked column
  - Profiler "Show full frequency →" link → opens panel for selected column (routes through same callback)
- Wired toolbar Frequency button in `handleAnalysisFeatureToggled()`:
  - Toggle on: opens panel for currently selected column (if any)
  - Toggle off: closes panel via `FrequencyPanelController.closeIfOpen()`
  - Button state synced to actual panel visibility after action
- Files changed: Sources/UI/FrequencyPanelController.swift (new), Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - NSPanel with `.utilityWindow` gives the floating utility window appearance (smaller title bar, stays above regular windows)
  - `becomesKeyOnlyIfNeeded = true` allows the panel to float without stealing focus from the main table — clicking in the main window doesn't need to close the panel first
  - NSPanel automatically handles Escape key dismissal when it's key — no need for custom `keyDown` override
  - The singleton pattern (static `shared`) works well for panels that should only have one instance — closing replaces rather than stacking
  - When showing frequency for a different column, the old panel is closed and a new one opened (updating title) rather than trying to mutate the existing panel in-place
  - The toolbar button state sync (`setFeatureActive`) must happen after the panel show/close action to reflect actual state (e.g., show may fail if no column is selected)
----

## 2026-02-26 - US-011 - Frequency table with sortable columns and inline bars
- Rewrote `Sources/UI/FrequencyPanelController.swift` to include a full NSTableView-based frequency table:
  - Table columns: Rank (#), Value, Count (with inline bar), Percentage (%)
  - Count column uses custom `FrequencyBarCellView` with a colored CALayer bar proportional to the max count
  - Cell formatting: monospaced digit fonts for numeric columns, thousands separators via NumberFormatter
  - Value column shows full value on tooltip, truncates with `.byTruncatingTail`
- Added sortable column headers using NSSortDescriptor prototypes:
  - Clicking column headers triggers `sortDescriptorsDidChange` delegate method
  - Supports sorting by rank, value (case-insensitive), count, and percentage
  - Default sort: count descending. Sort indicators (ascending/descending arrows) via `setIndicatorImage`
  - `sortColumn` and `sortAscending` state tracked for toggling behavior
- Added "Bin values" checkbox toggle for numeric columns:
  - Toggle only visible when column is numeric AND has >50 distinct values
  - When active, switches from `fetchFullFrequency` to `fetchBinnedFrequency` (WIDTH_BUCKET-based)
  - Bin labels computed from min/max/step (e.g., "1,000 – 2,000")
  - Toggle is hidden initially, shown/hidden after data loads based on distinct count
- Added toolbar bar with status label ("N distinct values") and NSProgressIndicator spinner during loading
- Extended `Sources/Engine/ProfilerQueryBuilder.swift` with two new query builders:
  - `buildFullFrequencyQuery()` — GROUP BY with no LIMIT for complete value frequency
  - `buildBinnedFrequencyQuery()` — WIDTH_BUCKET CTE for equal-width bins (10 buckets)
- Extended `Sources/Model/FileSession.swift`:
  - Added `FrequencyData` struct with `Row` type (value, count, percentage) and `totalNonNull` count
  - Added `fetchFullFrequency(columnName:completion:)` — no generation counter (panel-level, not profiler-level)
  - Added `fetchBinnedFrequency(columnName:completion:)` — for numeric bin mode
  - Both methods compute percentages from total non-null count
- Added `onValueClicked` and `onValueDoubleClicked` static callbacks on FrequencyPanelController for US-013 click-to-filter wiring
- Added `tableRowClicked` and `tableRowDoubleClicked` action methods (not filtering yet — that's US-013)
- Files changed: Sources/UI/FrequencyPanelController.swift, Sources/Engine/ProfilerQueryBuilder.swift, Sources/Model/FileSession.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - NSTableView `sortDescriptorPrototype` on NSTableColumn auto-enables clickable sort headers — `sortDescriptorsDidChange` fires with the new sort descriptors
  - `tableView.setIndicatorImage(_:in:)` draws the native sort arrow in column headers — pass `NSImage(named: "NSAscendingSortIndicator")` or `NSDescendingSortIndicator`
  - `tableView.highlightedTableColumn` controls which column header appears highlighted (darker background)
  - `FrequencyBarCellView` uses CALayer for the bar (not Core Graphics draw()) because `layout()` updates bar size on column resize without needing explicit `draw()` invalidation
  - The `binToggle?.isHidden = true` initial state prevents the toggle from appearing before data loads — it's shown/hidden in `handleFrequencyResult` based on `allRows.count > 50`
  - The frequency panel does NOT use the profiler generation counter since it's a separate panel with its own lifecycle — stale results aren't an issue because the panel is recreated for each column
  - `NSSortDescriptor(key:ascending:)` stores the sort key and direction — the NSTableView manages toggling direction on repeated clicks
----

## 2026-02-26 - US-012 - Frequency bar chart alongside table
- Created `Sources/UI/FrequencyBarChartView.swift`: custom NSView subclass drawing horizontal bars with Core Graphics
  - Each bar corresponds to a row in the frequency table, drawn proportional to count (largest = full width)
  - Uses `isFlipped = true` for top-to-bottom drawing, `headerOffset` property aligns bars with table header height
  - Bars drawn with system accent color at 0.6 alpha, rounded corners (3pt radius)
  - `intrinsicContentSize` computed from bar count for proper scroll view content sizing
  - Only draws bars within `dirtyRect` for efficient rendering with many rows
- Modified `Sources/UI/FrequencyPanelController.swift`:
  - Added NSSplitView (`splitView`) containing table scroll view (left) and chart scroll view (right)
  - Split view uses `.thin` divider style with NSSplitViewDelegate constraints (min table: 200pt, min chart: 80pt)
  - Initial split position: 70% table, 30% chart (set via `DispatchQueue.main.async` after layout)
  - Synchronized scrolling via `NSView.boundsDidChangeNotification` on both clip views with `isSyncingScroll` guard to prevent recursive updates
  - `updateBarChart()` method maps `displayRows` to chart bars, aligns `headerOffset` to table header height, and sizes chart document view to match content
  - Chart updates on both `sortAndReload()` and error state (empty data)
  - Panel default width increased from 500 to 650 to accommodate split layout
  - Added `NSSplitViewDelegate` conformance with min/max coordinate constraints
  - Scroll sync observers cleaned up in `windowWillClose`
  - Chart view uses `autoresizingMask = [.width]` to track scroll view width on split divider moves
- Files changed: Sources/UI/FrequencyBarChartView.swift (new), Sources/UI/FrequencyPanelController.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - `NSView.boundsDidChangeNotification` on `scrollView.contentView` (the clip view) fires on scroll — must set `postsBoundsChangedNotifications = true` first
  - Synchronized scrolling between two NSScrollViews requires a `isSyncingScroll` guard to prevent infinite recursion — setting one clip view's bounds triggers the other's notification
  - `reflectScrolledClipView(_:)` must be called after `setBoundsOrigin` to update the scroll view's scrollers to match the new position
  - NSSplitView with `addArrangedSubview` and Auto Layout constraints is cleaner than manual frame management for the split layout
  - `DispatchQueue.main.async` for initial split position is needed because `splitView.bounds` is zero during `setupUI()` — the layout hasn't happened yet
  - Chart document view height must be `max(contentHeight, clipViewHeight)` to prevent the chart from being smaller than the visible area when there are few rows
  - `autoresizingMask = [.width]` on the chart view makes it automatically resize when the split divider moves, without needing explicit frame updates or notification observers
----

## 2026-02-26 - US-013 - Click-to-filter from frequency view
- Wired `FrequencyPanelController.onValueClicked` static callback in `applicationDidFinishLaunching`:
  - Single-click a frequency table row → replaces any existing filter for that column with `ColumnFilter(column:, operator: .equals, value: .string(value))`, then calls `handleFiltersChanged`
  - Filter bar updates, status bar shows "showing X of Y rows", frequency panel stays open
- Wired `FrequencyPanelController.onValueDoubleClicked` static callback:
  - Double-click a frequency table row → adds the same filter AND calls `FrequencyPanelController.closeIfOpen()` to dismiss the panel
- Both callbacks use the same replace-existing-filter pattern as the profiler's TopValues click-to-filter: `filters.removeAll { $0.column == columnName }` before appending
- `handleFiltersChanged` (existing method) handles the entire downstream flow: ViewState update, cache invalidation, page re-fetch, filter bar update, status bar update
- Binned mode rows are excluded from click-to-filter (guard `!isBinned` in `tableRowClicked`/`tableRowDoubleClicked` — already implemented in US-011)
- Files changed: Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - The `FrequencyPanelController.onValueClicked`/`onValueDoubleClicked` callbacks and the `tableRowClicked`/`tableRowDoubleClicked` action methods were already scaffolded in US-011 — US-013 only needed to wire the callbacks to the filter infrastructure in AppDelegate
  - Static callbacks on FrequencyPanelController are wired once in `applicationDidFinishLaunching`, not per-TVC in `showTableView` — the panel is a singleton that operates across all tabs
  - **Bug fix (review feedback):** The initial implementation used `activeTab?.fileSession` which targets the wrong tab when a different window is focused while the floating frequency panel is open. Fixed by passing the panel's own `fileSession` through the callback and looking up the owning tab via `tab(for: FileSession)`
  - Changed callback signatures from `((String, String) -> Void)?` to `((String, String, FileSession) -> Void)?` so the panel passes its session
  - Added `tab(for: FileSession)` helper on AppDelegate (matching existing `tab(for: TableViewController)` pattern)
  - Created `applyFrequencyFilter(columnName:value:session:)` method that targets a specific session/TVC instead of relying on `handleFiltersChanged` which uses `activeTab`
  - The replace-existing-filter pattern (`removeAll` + `append`) prevents duplicate filter chips when clicking multiple values in the same column
----

## 2026-02-26 - US-014 - Compute and cache column summaries on file load
- Created Sources/Model/ColumnSummary.swift with `ColumnSummary` struct and `Distribution` enum:
  - `ColumnSummary`: columnName, detectedType, cardinality (distinct count), nullCount, totalRows, distribution, computed `completeness` property
  - `Distribution` enum with 4 cases: `.histogram(buckets:)` for numeric, `.frequency(values:)` for low-cardinality categorical (≤15 unique), `.boolean(trueCount:falseCount:)` for booleans, `.highCardinality(uniqueCount:)` for high-cardinality text (>15 unique)
- Extended ProfilerQueryBuilder with 4 new summary-specific query builders:
  - `buildBatchCardinalityQuery(columns:)` — UNION ALL query fetching cardinality + null count for ALL columns in a single query (batch optimization)
  - `buildSummaryNumericHistogramQuery(columnName:)` — WIDTH_BUCKET histogram with no WHERE filter (all data)
  - `buildSummaryCategoricalFrequencyQuery(columnName:limit:)` — top-N frequency query with no WHERE filter
  - `buildSummaryBooleanDistributionQuery(columnName:)` — true/false counts with no WHERE filter
- Extended FileSession with summary computation infrastructure:
  - `summaryGeneration: Int` counter for discarding stale summary results (matching profilerGeneration pattern)
  - `columnSummaries: [String: ColumnSummary]` cached dictionary
  - `onSummariesComputed: (() -> Void)?` callback for UI updates (US-015 sparklines)
  - `computeColumnSummaries()` — two-phase batch computation: (1) single UNION ALL query for cardinality/nulls across all columns, (2) per-column distribution queries based on type + cardinality. Each phase checks generation counter for early abort
  - `invalidateColumnSummaries()` — increments generation counter and clears cache
  - Private helpers: `computeBooleanDistribution`, `computeNumericDistribution`, `computeCategoricalDistribution`
- Added `invalidateColumnSummaries()` calls to ALL data mutation methods:
  - `updateCell` (cell edit), `deleteRows` (row deletion), `deleteColumn` (column deletion), `addColumn` (column addition), `renameColumn` (column rename), `changeColumnType` (type change), `reloadTable` (header/delimiter/encoding reload), `addRow` (new row)
- Triggered `session.computeColumnSummaries()` in AppDelegate after:
  - `loadFull` completion (initial file load)
  - `reload(withHeaders:)` completion (header toggle reload)
  - `reload(withDelimiter:)` completion (delimiter change reload)
  - `reload(withEncoding:)` completion (encoding change reload)
- Files changed: Sources/Model/ColumnSummary.swift (new), Sources/Engine/ProfilerQueryBuilder.swift, Sources/Model/FileSession.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - The batch UNION ALL cardinality query avoids N individual queries — much more efficient for files with many columns
  - Summary distribution queries intentionally have NO WHERE filter clause — they summarize the entire dataset, not the filtered view. This is different from profiler queries which respect ViewState filters
  - The `summaryGeneration` counter is separate from `profilerGeneration` — they serve different lifecycles (summaries are invalidated on data mutation, profiler on column selection/filter change)
  - `DispatchQueue.main.sync` is used for generation counter checks within the queryQueue async block — this is safe because main thread doesn't call into queryQueue synchronously (no deadlock risk)
  - The summary computation is designed for sparkline rendering (US-015) — the Distribution enum's 4 cases map directly to the sparkline visual types: mini histogram, mini frequency bars, two-segment boolean bar, and "N unique" text badge
  - The `onSummariesComputed` callback will be wired in US-015 to trigger header sparkline rendering once summaries are available
  - Categorical distribution uses a threshold of 15 unique values (matching US-015 sparkline requirement), not 50 (which is used by the profiler's distribution section)
----

## 2026-02-26 - US-015 - Render sparklines in column headers
- Created Sources/UI/SparklineHeaderCell.swift — custom NSTableHeaderCell subclass that draws mini sparkline visualizations below the column name text using Core Graphics
- Four sparkline types based on Distribution enum:
  - **Numeric columns (.histogram):** Mini vertical bar chart with 8-10 bars showing distribution shape, using systemBlue
  - **Low-cardinality categorical (.frequency, ≤15 unique):** Mini vertical bars for top values sorted by frequency, using systemTeal
  - **Boolean columns (.boolean):** Two-segment horizontal bar with proportional true/false widths (green/red) and percentage labels
  - **High-cardinality text (.highCardinality, >15 unique):** Text badge showing "N unique" in secondaryLabelColor
- Updated AutoFitTableHeaderView header height from 23pt to 44pt (via SparklineHeaderCell.totalHeaderHeight) to accommodate sparkline row (~16pt sparkline area below text)
- Updated TableViewController.makeTableColumn() to use SparklineHeaderCell instead of default NSTableHeaderCell, applying column summary data when available
- Added TableViewController.updateSparklines() method that iterates all table columns, updates their SparklineHeaderCell.columnSummary from FileSession.columnSummaries cache, and marks headerView for redisplay
- Wired FileSession.onSummariesComputed callback in AppDelegate.openFile() to call tab?.tableViewController?.updateSparklines() — triggers header refresh when column summaries finish computing after file load
- Sparklines use cached ColumnSummary data (computed in US-014) — no queries on render, instant display
- Drawing uses Core Graphics: CGPath(roundedRect:) for bars, ctx.saveGState/restoreGState for state management, NSString.draw(at:withAttributes:) for text labels
- Manually added SparklineHeaderCell.swift to Gridka.xcodeproj/project.pbxproj (PBXBuildFile, PBXFileReference, UI group, Sources build phase)
- Files changed: Sources/UI/SparklineHeaderCell.swift (new), Sources/UI/TableViewController.swift, Sources/App/AppDelegate.swift, Gridka.xcodeproj/project.pbxproj, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - NSTableHeaderCell can be subclassed and assigned to column.headerCell — the cell's draw(withFrame:in:) is called by the header view for each column
  - To increase header height, set the frame height in the AutoFitTableHeaderView init (NSTableHeaderView subclass)
  - The sparkline drawing area is computed as the lower portion of the cell frame; the upper portion is passed to super.draw() for standard text rendering
  - Clipping the CGContext to the sparkline frame prevents sparkline drawing from overflowing into the text area
  - xcodegen was not accessible via CLI, so the pbxproj was manually edited to add the new file — requires 4 additions: PBXBuildFile, PBXFileReference, group children entry, and Sources build phase entry
  - SparklineHeaderCell.columnSummary is set in two paths: (1) during makeTableColumn when configuring columns, and (2) via updateSparklines() when summaries finish computing asynchronously
  - The onSummariesComputed callback is set once in openFile() alongside onModifiedChanged — it persists across reload operations since the same session is reused
----

## 2026-02-26 - US-016 - Click sparkline to open profiler for that column
- Added sparkline click detection to AutoFitTableHeaderView.mouseDown(with:):
  - New `sparklineColumnIndex(at:)` method checks if click point Y is within the lower sparkline area (y >= totalHeaderHeight - sparklineHeight = 28pt in flipped coordinates)
  - If in sparkline area, identifies which column was clicked by iterating column x-offsets
  - Sparkline click check runs before sort indicator check, since sort indicators are in the upper text region
- Added `handleSparklineClick(columnIndex:)` method to TableViewController:
  - Resolves column index to column name and calls `onSparklineClicked` callback
  - Guards against invalid index, unloaded file, same pattern as `handleSortIndicatorClick`
- Added `onSparklineClicked: ((String) -> Void)?` callback on TableViewController
- Wired `onSparklineClicked` callback in AppDelegate (in `showTableView`):
  - Calls `handleColumnSelected(tab:columnName:)` to select the column (updates ViewState, profiler content)
  - Opens profiler sidebar via `tvc.toggleProfilerSidebar()` if not already visible
  - If profiler is already open, just switches to the clicked column (via handleColumnSelected)
- Click target distinction: clicking the lower ~16pt (sparkline area) of a header triggers sparkline behavior (select + open profiler); clicking the upper ~27pt (column name text area) triggers standard column select behavior (per US-001)
- Files changed: Sources/UI/TableViewController.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - NSTableHeaderView is flipped (y=0 at top), so the sparkline area threshold is `y >= totalHeaderHeight - sparklineHeight` (i.e., y >= 28pt)
  - The sparkline click check must come before the sort indicator click check in mouseDown — both check `event.clickCount == 1` without Option, but the sparkline area and sort indicator area can overlap (sort indicator is in the rightmost 24pt of sorted columns, which spans the full height including sparkline area)
  - `SparklineHeaderCell.sparklineHeight` and `totalHeaderHeight` are already `static let` properties, making them accessible from AutoFitTableHeaderView for hit-testing
  - The `onSparklineClicked` callback uses the same weak-self + tab-lookup pattern as `onColumnSelected` and other callbacks wired in `showTableView`
----

## 2026-02-26 - US-017 - Computed column dialog with expression editor
- Created Sources/UI/ComputedColumnPanelController.swift — floating NSPanel (utility window, non-activating) for defining computed columns with DuckDB SQL expressions
- Panel UI contains:
  - Column Name text field with placeholder "computed_column"
  - Multi-line expression text area (NSTextView with monospace font) wrapped in NSScrollView with bezel border
  - 14 function hint chips in flow layout (ROUND, UPPER, LOWER, LENGTH, YEAR, MONTH, CASE...END, CONCAT, COALESCE, CAST, REGEXP_EXTRACT, TRIM, REPLACE, SUBSTR)
  - Error label (red text, hidden by default) for inline validation
  - Cancel (Escape) and Add Column (Enter) buttons; Add Column disabled until both fields non-empty
- Clicking a function hint chip inserts the template at cursor position in expression editor and positions cursor inside the first parentheses
- Panel follows the FrequencyPanelController singleton pattern: static shared instance, show/closeIfOpen/isVisible/closeIfOwned(by:)
- Session frame persistence (position remembered within session, not across launches)
- Inline validation: duplicate column name shows error, empty fields disable Add Column button
- `isReleasedWhenClosed = false` set on NSPanel (critical ARC safety — see MEMORY.md)
- Wired three trigger points:
  1. Toolbar button: AnalysisToolbarView .computedColumn toggle -> handleAnalysisFeatureToggled -> ComputedColumnPanelController.show()
  2. Edit menu: "Add Computed Column..." with Opt+Cmd+F keyboard shortcut -> addComputedColumnAction
  3. Panel close: onClose callback syncs toolbar button state across all tabs
- Added menu validation: "Add Computed Column..." enabled only when session is fully loaded
- Added tab close cleanup: ComputedColumnPanelController.closeIfOwned(by:) called alongside FrequencyPanelController cleanup
- Manually added ComputedColumnPanelController.swift to Gridka.xcodeproj/project.pbxproj (PBXBuildFile, PBXFileReference, UI group, Sources build phase)
- Files changed: Sources/UI/ComputedColumnPanelController.swift (new), Sources/App/AppDelegate.swift, Gridka.xcodeproj/project.pbxproj, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - NSTextView in an NSScrollView needs `autoresizingMask = [.width]`, `isVerticallyResizable = true`, and `textContainer?.widthTracksTextView = true` for proper text wrapping and vertical expansion
  - NSTextView.insertText(_:replacementRange:) inserts at the selected range; use setSelectedRange to position cursor after insertion
  - The .inline bezel style for NSButton creates compact chip-like buttons suitable for tag/chip UIs
  - Function hint chips use a manual flow layout approximation with multiple horizontal NSStackViews inside a vertical NSStackView — true NSCollectionView would be overkill for ~14 fixed items
  - The AnalysisToolbarView already had `.computedColumn` as an enum case with the "function" SF Symbol — only the handler in AppDelegate needed implementation
  - For NSPanel floating utility windows, `becomesKeyOnlyIfNeeded = true` allows the main window to remain key when the panel doesn't need keyboard input, but the expression text view still receives focus when clicked
----

## 2026-02-26 - US-018 - Live preview for computed column expression
- Added `fetchComputedColumnPreview(expression:columnName:completion:)` to FileSession:
  - Selects up to 3 existing columns for context plus `(expression) AS new_col FROM data LIMIT 5`
  - Runs on the serial `queryQueue`, returns `ComputedColumnPreview` (columnNames + rows of strings) on main thread
  - Errors (syntax errors, invalid expressions) propagated via Result type for inline display
- Extended ComputedColumnPanelController with live preview section (US-018):
  - PREVIEW label and NSTableView (5-row, non-scrollable) below the function hint chips
  - Preview table has dynamic columns: context columns from the data + the computed column (highlighted with accent color header and tinted cell background)
  - NSTableViewDataSource/Delegate conformance added for preview table data
  - 300ms debounce using DispatchWorkItem pattern (cancel previous, schedule new) — same pattern as SearchBarView/profiler debounce
  - On successful preview: hides error, configures table columns, reloads data
  - On DuckDB error: shows error message in red below expression field, hides preview table
  - Preview hidden when expression is empty; appears automatically on first valid input
  - Debounce work item cancelled on window close to prevent stale callbacks
- Panel default height increased from 420 to 560 to accommodate the preview section; min height increased from 340 to 420
- Expression scroll view minimum height reduced from 80 to 60 to leave more room for preview
- Added `schedulePreviewUpdate()` calls to both `textDidChange` (expression editing) and `chipClicked` (function template insertion)
- Files changed: Sources/Model/FileSession.swift, Sources/UI/ComputedColumnPanelController.swift, plans/prd.json
- Build succeeds, all 64 tests pass
- **Learnings for future iterations:**
  - `DuckDBValue` conforms to `CustomStringConvertible` — `.description` provides clean string representation for preview cells, avoiding a manual switch on all value types
  - NSTableView with dynamic columns: remove all existing columns via `removeTableColumn` in a reversed loop, then add new ones. Column identifiers must be unique per rebuild
  - The preview query uses `(expression) AS quotedName` — parentheses around the expression ensure operator precedence doesn't break the query
  - DispatchWorkItem cancel pattern: the cancelled flag is checked lazily, so cancelling a pending work item prevents it from executing even if it's already in the dispatch queue
  - NSTableHeaderCell's `attributedStringValue` can be set directly to highlight the computed column header in accent color — no need to subclass
  - The preview section is positioned between the error label and the buttons, using Auto Layout constraints with `topAnchor.constraint(greaterThanOrEqualTo:)` on buttons to keep them pinned to the bottom
  - `previewContainer.isHidden = true` initially keeps the preview area collapsed until the first valid expression is entered
----

## 2026-02-26 - US-019 - Add computed column to table and QueryCoordinator
- Created `ComputedColumn` struct (name + expression) in ViewState.swift, added `computedColumns: [ComputedColumn]` to ViewState with equality check
- Updated `QueryCoordinator.buildQuery()` and `buildCountQuery()` to wrap data source in a subquery when computed columns exist:
  - `SELECT * FROM (SELECT *, (expr1) AS "name1", (expr2) AS "name2" FROM data) WHERE ... ORDER BY ... LIMIT ... OFFSET ...`
  - New private `buildSourceExpression(for:)` method returns plain `data` or the subquery
- Updated `buildSearchCondition` to include computed columns in global search (ORs across base + computed columns)
- Updated `FileSession.updateViewState()` to invalidate row cache when computed columns change
- Updated `ComputedColumnPanelController` init to include existing computed column names in duplicate validation
- Wired `ComputedColumnPanelController.onAddColumn` callback in AppDelegate:
  - `handleComputedColumnAdded(name:expression:)` adds ComputedColumn to ViewState, adds table column, re-fetches page 0
- Added computed column display in TableViewController:
  - `addComputedColumn(name:)` / `removeComputedColumn(name:)` methods manage NSTableColumns
  - `makeComputedTableColumn(name:)` creates columns with formula indicator (ƒ prefix in purple, italic name)
  - `styleComputedHeaderCell()` for sort/selection state updates on computed column headers
  - `computedColumnNames: Set<String>` tracks which columns are computed
  - `configureColumns()` re-adds computed columns after base column reconfiguration
- Added 'Remove Computed Column' context menu item for computed columns:
  - Computed columns get a simplified context menu (Filter + Remove Computed Column only)
  - `onComputedColumnRemoved` callback wired to `handleComputedColumnRemoved(tab:columnName:)` in AppDelegate
  - Removal also cleans up any sorts/filters referencing the removed computed column
- Computed columns are not editable (inline editing guard added)
- Added 6 new QueryCoordinator tests: single/multiple computed columns, count query, filter+sort on computed, empty computed columns, search with computed
- Files changed: Sources/Model/ViewState.swift, Sources/Engine/QueryCoordinator.swift, Sources/Model/FileSession.swift, Sources/UI/TableViewController.swift, Sources/UI/ComputedColumnPanelController.swift, Sources/App/AppDelegate.swift, Tests/QueryCoordinatorTests.swift, plans/prd.json
- Build succeeds, all 70 tests pass (6 new)
- **Learnings for future iterations:**
  - `NSFont.italicSystemFont` doesn't exist in AppKit — use `NSFontManager.shared.convert(font, toHaveTrait: .italicFontMask)` instead
  - Computed columns are virtual (only in SELECT), not in the DuckDB table schema — `FileSession.columns` stays unchanged, only `ViewState.computedColumns` and the table view track them
  - The subquery approach `(SELECT *, (expr) AS name FROM data)` allows WHERE/ORDER BY/LIMIT to reference computed column names directly, since the outer query sees them as regular columns
  - `updateSortIndicators()` needs to handle computed columns separately since they have no ColumnDescriptor — a dedicated `styleComputedHeaderCell` method preserves the formula indicator styling
  - The row cache automatically includes computed column data because the page's `columnNames` array comes from the DuckDB result which now includes the computed column expressions in SELECT
  - `configureColumns()` is called when base columns change (reload, column delete); it needs to re-add computed columns afterward since it removes all table columns first
  - Computed column removal in AppDelegate also cleans up ViewState: removes sorts, filters, and selectedColumn referencing the deleted computed column
----

## 2026-02-26 - US-020 - Save As prompt for tabs with computed columns
- Added `exportWithComputedColumns(to:completion:)` method to FileSession:
  - Uses `QueryCoordinator.buildSourceExpression()` to build the source subquery with computed column expressions
  - Builds explicit column list: base columns (excluding _gridka_rowid) + computed column names
  - Exports via DuckDB `COPY (SELECT columns FROM source) TO 'path' (FORMAT CSV, HEADER true, DELIMITER ',', FORCE_QUOTE *)`
  - Runs on serial `queryQueue`, completes on main thread — original file never modified
- Modified `windowShouldClose(_:)` in AppDelegate to detect computed columns:
  - Checks both `session.isModified` (unsaved edits) and `!session.viewState.computedColumns.isEmpty` (computed columns present)
  - When only edits: shows existing save prompt (Save/Don't Save/Cancel)
  - When only computed columns: shows computed columns prompt directly
  - When both: shows edit save prompt first, then chains to computed columns prompt after edit save/discard
- Added `showComputedColumnsSavePrompt(for:session:)`:
  - NSAlert with message "This tab has computed columns." and informative text "Save a copy with computed values included?"
  - Three buttons: "Save As…" (opens NSSavePanel), "Discard" (closes without saving), "Cancel" (stays on tab)
- Added `showComputedColumnsExportPanel(for:session:)`:
  - NSSavePanel with `.commaSeparatedText` content type, default filename `<original>_computed.csv`
  - Semi-transparent overlay with spinning NSProgressIndicator during export
  - On success: overlay removed, window closes via `windowsClosingAfterPrompt` set
  - On failure: overlay removed, error shown via `showError`
  - Cancel on save panel returns to tab without closing
- Files changed: Sources/Model/FileSession.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 71 tests pass
- **Learnings for future iterations:**
  - The `windowShouldClose` → alert → save panel chain requires careful handling of weak references and the `windowsClosingAfterPrompt` set to prevent infinite recursion
  - When both `isModified` and computed columns are present, the save prompt must chain: first handle edits (save/discard), then handle computed columns (save as/discard) — two sequential async prompts
  - `QueryCoordinator.buildSourceExpression()` already encapsulates the computed column subquery logic — reusing it for export avoids duplicating the SQL generation
  - NSSavePanel.beginSheetModal is async — the export must happen in the completion handler, and the progress overlay must be added/removed on main thread
  - The export intentionally does NOT update `session.filePath` or `session.isModified` — the original file is untouched and the computed columns remain in the ViewState (the tab is about to close anyway)
  - The semi-transparent overlay prevents user interaction with the table during export and provides visual feedback for large file exports
----

## 2026-02-26 - US-021 - Group By builder dialog with column zones
- Created Sources/UI/GroupByPanelController.swift — floating NSPanel (utility window, non-activating) for building Group By aggregation queries visually
- Panel has three areas:
  - **Available Columns (left):** NSTableView listing all file columns with color-coded type dots (blue=text, green=integer/float, orange=date, purple=boolean)
  - **Group By zone (top-right):** NSStackView with removable pill-style NSViews showing grouped columns, placeholder text when empty
  - **Aggregations zone (bottom-right):** NSStackView with pills containing NSPopUpButton function dropdown (COUNT, SUM, AVG, MIN, MAX, MEDIAN) and removable × button
- Click-to-add behavior:
  - Single-click adds column to default zone: categorical/date/boolean → Group By, numeric → Aggregations
  - Double-click adds to alternate zone: categorical → Aggregations, numeric → Group By
  - Hint label below columns list explains: "Click: default zone · Double-click: other zone"
- COUNT(*) aggregation added by default when panel opens
- Cancel (Escape) and "Open as New Tab" (Enter) buttons; Open button disabled until at least one aggregation exists
- Panel follows singleton pattern (same as ComputedColumnPanelController/FrequencyPanelController):
  - Static shared instance, show/closeIfOpen/isVisible/closeIfOwned(by:)
  - `isReleasedWhenClosed = false` (critical ARC safety)
  - Session frame persistence within app session
- Supporting types: AggregationFunction enum, AggregationEntry struct, GroupByDefinition struct
- Wired three trigger points in AppDelegate:
  1. Toolbar button: AnalysisToolbarView .groupBy toggle → handleAnalysisFeatureToggled → GroupByPanelController.show()
  2. Edit menu: "Group By…" with Opt+Cmd+G keyboard shortcut → groupByAction
  3. Panel close: onClose callback syncs toolbar button state across all tabs
- Added menu validation: "Group By…" enabled only when session is fully loaded
- Added tab close cleanup: GroupByPanelController.closeIfOwned(by:) called alongside Frequency/ComputedColumn cleanup
- onOpenAsNewTab callback wired with placeholder NSLog (actual implementation in US-023)
- FlippedView helper class for top-to-bottom scroll content in zone scroll views
- Files changed: Sources/UI/GroupByPanelController.swift (new), Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 71 tests pass
- **Learnings for future iterations:**
  - NSView.tag is read-only in newer macOS SDKs — use NSUserInterfaceItemIdentifier (`.identifier`) instead for tagging subviews in reusable cells
  - xcodeproj is gitignored and generated by xcodegen — new files in Sources/ are auto-included, but manual pbxproj edits are needed for the current build to succeed before xcodegen is re-run
  - The pill UI pattern (colored background, type dot, label, × button) is reusable across Group By and Aggregations zones — only the middle content (label vs popup+label) differs
  - NSPopUpButton with `.tag` set to the pill index enables identifying which aggregation entry to update in the `aggregationFunctionChanged` handler
  - The "default zone" heuristic (categorical → Group By, numeric → Aggregations) works well for quick use, while double-click provides escape hatch to override
  - NSStackView inside NSScrollView needs a FlippedView (isFlipped = true) wrapper as the document view for top-to-bottom content flow
  - The Group By definition struct (groupByColumns + aggregations) cleanly encapsulates the builder state for passing to US-023's new-tab creation
----

## 2026-02-26, 19:55 - US-022 - Live preview for Group By results
- Added `fetchGroupByPreview` method to FileSession: executes preview query (top 5 groups by COUNT(*) DESC) + total group count query on the serial queryQueue, returns `GroupByPreview` struct with columnNames, rows, totalGroups
- Added preview section to GroupByPanelController: NSTableView with dynamic columns, "PREVIEW" title label, spinning progress indicator, "N groups total" count label
- Implemented 500ms debounced preview updates via `DispatchWorkItem` pattern (same as ComputedColumnPanelController's 300ms debounce)
- Preview is triggered on every zone change: addToGroupBy, removeFromGroupBy, addToAggregations, removeFromAggregations, aggregationFunctionChanged
- Generation counter (`previewGeneration`) discards stale results when user changes configuration while query is in-flight
- Initial preview fires automatically for the default COUNT(*) aggregation on panel open
- When no group-by columns selected, shows overall aggregation (single row) — count query returns 1
- Panel height increased from 480→620pt, minSize from 360→480pt to accommodate preview
- Files changed: Sources/Model/FileSession.swift, Sources/UI/GroupByPanelController.swift
- Build succeeds, all 71 tests pass
- **Learnings for future iterations:**
  - The debounce + generation counter pattern is now used in 3 places: ProfilerSidebarViewController (200ms), ComputedColumnPanelController (300ms), GroupByPanelController (500ms) — consider extracting a shared utility
  - Preview table columns must be rebuilt dynamically since group-by and aggregation selections change the result schema
  - NSTableView `makeView(withIdentifier:owner:)` reuse works for preview cells but columns must be recreated from scratch each time (remove all + re-add)
  - For the count query with no group-by columns, `SELECT 1` correctly returns 1 group (the overall aggregation row)
  - The FileSession.fetchGroupByPreview uses the same queryCoordinator.buildSourceExpression + buildWhereSQL to respect computed columns and active filters
----

## 2026-02-26, 20:05 - US-023 - Open Group By results as new tab
- Added summary session support to FileSession:
  - `summaryTableName: String?` property and `isSummarySession` computed property
  - Static `createSummarySession(from:definition:completion:)` factory method that shares the source session's DuckDB engine and queryQueue, creates a `CREATE TEMP TABLE summary_N AS SELECT ...` with the Group By aggregation, extracts column metadata, and returns a pre-configured FileSession
  - `dropSummaryTable()` method that executes `DROP TABLE IF EXISTS` on the shared queryQueue
  - Static `summaryCounter` for unique temp table names (summary_1, summary_2, ...)
  - Changed `queryQueue` from `let` with inline init to `let` with init-time assignment to support both regular and summary session inits
- Added `openGroupBySummary(definition:sourceSession:)` to AppDelegate:
  - Replaces the placeholder `onOpenAsNewTab` callback from US-021
  - Creates a summary session via the factory method
  - Opens a new tab window with title "Summary: by column1, column2" (or "Summary: overall" when no group-by columns)
  - Sets up TableViewController with configureColumns + autoFitAllColumns
  - Status bar shows total group count
  - Rebalances memory limits across all tabs
- Updated windowWillClose to call `session.dropSummaryTable()` for temp table cleanup
- Updated windowShouldClose to skip save/computed-column prompts for summary sessions (`isSummarySession` early return)
- Summary tabs support full table functionality: sorting, filtering, searching, Profiler, Frequency analysis
- Files changed: Sources/Model/FileSession.swift, Sources/App/AppDelegate.swift, plans/prd.json
- Build succeeds, all 71 tests pass
- **Learnings for future iterations:**
  - Summary sessions share the DuckDB engine and queryQueue with their source session — the engine stays alive via ARC reference counting as long as any session holds a reference. This means closing the source tab before the summary tab is safe.
  - DuckDB temp tables (`CREATE TEMP TABLE`) are scoped to the connection, so they're visible to both source and summary sessions sharing the same engine/connection. No need for regular tables.
  - The `queryQueue` declaration was changed from inline-initialized `let` to init-assigned `let` to support the private summary init. This is a non-breaking change since DispatchQueue is a reference type.
  - The existing `tableName` property on FileSession (defaulting to "data") naturally supports summary sessions — QueryCoordinator's `buildSourceExpression` returns "data" for non-computed-column queries, but for summary sessions the tableName is set to the temp table name directly, and since summary sessions have no computed columns, the query simply becomes `SELECT * FROM summary_N`.
  - The rebalanceMemoryLimits doesn't double-count summary sessions that share an engine — memory limit SET calls go through the shared queryQueue and engine, so the last-applied limit wins. This is acceptable since summary tabs use negligible memory compared to source data.
----

## 2026-02-26, 20:12 - US-023 - Review fixes: harden summary tab
- **P1 fix**: Made summary tabs strictly read-only by disabling all mutating menu items in `validateMenuItem` (save, saveAs, addColumn, renameColumn, deleteColumn, addRow, deleteRows, toggleHeader, changeDelimiter, changeEncoding, customDelimiter) and guarding `onCellEdited` callback. The `isSummarySession` check is early-exit for each action.
- **P2 fix (profiler)**: Added `tableName` computed property to `ProfilerQueryBuilder` that proxies through to its internal `QueryCoordinator.tableName`. Set in FileSession's summary init alongside the main queryCoordinator. Also replaced hardcoded `FROM data` in 4 batch summary methods (buildBatchCardinalityQuery, buildSummaryNumericHistogramQuery, buildSummaryCategoricalFrequencyQuery, buildSummaryBooleanDistributionQuery) with `FROM \(tableName)`.
- **P2 fix (cleanup)**: Changed `dropSummaryTable()` to capture `engine` strongly (not `[weak self]`) so the DROP TABLE executes reliably even if the FileSession is deallocated before the serial queue drains.
- Files changed: Sources/App/AppDelegate.swift, Sources/Engine/ProfilerQueryBuilder.swift, Sources/Model/FileSession.swift
- Build succeeds, all 71 tests pass
- **Learnings for future iterations:**
  - When introducing a new session type (summary), audit ALL query-building paths — not just QueryCoordinator but also ProfilerQueryBuilder and any other query builders that have their own QueryCoordinator instances.
  - Cleanup work items dispatched to a serial queue must capture resources strongly if the owning object may be deallocated before the queue drains. Using `[weak self]` is safe for queries (skipping is harmless) but wrong for cleanup (skipping leaks resources).
  - Menu validation is the correct AppKit mechanism for making sessions read-only — it covers all menu actions, keyboard shortcuts, and toolbar items in one place. No need to scatter guards across individual action handlers.
----

## 2026-02-26, 20:30 - US-101 - Add view-state generation token for page fetches
- Added `viewStateGeneration: Int` monotonic counter to FileSession (main-thread only)
- `fetchPage` captures the generation before dispatching to queryQueue; callback checks generation matches before calling `rowCache.insertPage` — stale results are silently discarded
- Created `invalidateRowCache()` private helper that atomically bumps generation + clears cache
- Replaced all 10 `rowCache.invalidateAll()` call sites with `invalidateRowCache()` — covers: full file load, reload (header/delimiter/encoding), column add/delete/rename, row delete, and `updateViewState`
- Single-page invalidations (`invalidatePage`) intentionally left without generation bump — they don't change query shape (sort/filter/search unchanged) so in-flight fetches for other pages remain valid
- Files changed: Sources/Model/FileSession.swift, plans/prd.json
- Build succeeds, all 71 tests pass
- **Learnings for future iterations:**
  - The generation counter pattern is now used in 4 places in FileSession: `viewStateGeneration` (page fetches), `profilerGeneration` (profiler queries), `summaryGeneration` (column summaries), and `previewGeneration` (Group By preview in GroupByPanelController)
  - All cache invalidation should go through a single helper method to ensure generation is always bumped alongside the cache clear — prevents forgetting one or the other
  - The `fetchPage` completion is suppressed (not called) when generation is stale, which is safe because callers (TableViewController.requestPageFetch, AppDelegate sort/filter handlers) only use the completion to reload visible rows — stale data would cause incorrect display
  - `rowCache.invalidatePage` (singular) for cell edits doesn't need generation bumping because the in-flight fetch used the same SQL query shape; worst case it re-inserts the pre-edit value which gets corrected on next access
----
