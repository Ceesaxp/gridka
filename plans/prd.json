{
  "project": "Gridka",
  "branchName": "ralph/analysis-features",
  "description": "Analysis Features — Transform Gridka from a CSV viewer into a CSV explorer with Column Profiler, Frequency View, Sparklines, Computed Columns, and Group By aggregation. All powered by DuckDB SQL through the existing ViewState → QueryCoordinator pipeline.",
  "userStories": [
    {
      "id": "US-001",
      "title": "Rewire column header click to select instead of sort",
      "description": "As a user, I want to select a column by clicking its header so that the profiler and other analysis features can target that column, while sort remains accessible via Opt+click or the sort indicator.",
      "acceptanceCriteria": [
        "Single-click on column header selects the column (visually highlights the header with a tinted background or border)",
        "Add selectedColumn: String? to ViewState; clicking a header updates this value",
        "Option+click on column header sorts by that column (ascending, or toggles direction if already sorted by that column)",
        "Shift+Option+click adds column to multi-column sort (existing behavior, relocated)",
        "Right-click on column header opens existing context menu (preserved)",
        "A small sort indicator glyph (arrow) appears in headers of currently-sorted columns",
        "Clicking directly on the sort indicator area also triggers sort (no Option key needed)",
        "Compiles and passes existing tests"
      ],
      "priority": 1,
      "passes": true,
      "notes": "This is a breaking UX change from click-to-sort to click-to-select. The sort indicator affordance is critical for discoverability. Look at existing NSTableHeaderCell / column header view code. The selectedColumn state drives the Profiler sidebar content in later stories."
    },
    {
      "id": "US-002",
      "title": "Add analysis toolbar below tab bar",
      "description": "As a user, I want a toolbar row with analysis feature buttons so I can quickly toggle the Profiler, Frequency, Group By, and Computed Column features.",
      "acceptanceCriteria": [
        "A horizontal toolbar row appears below the tab bar (above the table) when enabled",
        "Toolbar contains toggle buttons with icons and short labels: Profiler, Frequency, Group By, Computed Column",
        "Each button has an active/pressed state when its corresponding panel is open",
        "Toolbar is hidden by default; toggled via View menu → 'Show Analysis Toolbar'",
        "Keyboard shortcut Opt+Cmd+T toggles toolbar visibility",
        "Toolbar visibility preference persists across sessions via SettingsManager",
        "Compiles and passes existing tests"
      ],
      "priority": 2,
      "passes": true,
      "notes": "Use NSView or NSStackView for the toolbar row. Buttons should use SF Symbols for icons (chart.bar, list.number, function, rectangle.3.group). The toolbar state (visible/hidden) is stored in SettingsManager for persistence."
    },
    {
      "id": "US-003",
      "title": "Create profiler sidebar container with NSSplitView",
      "description": "As a user, I want a right sidebar panel that appears when I toggle the profiler, so I can see column details alongside the table.",
      "acceptanceCriteria": [
        "A right sidebar (300pt wide) appears in an NSSplitView when the Profiler is toggled on",
        "Sidebar is scrollable (NSScrollView wrapping an NSStackView with sections)",
        "Toggle via: toolbar Profiler button, Shift+Cmd+P shortcut, or View menu → 'Toggle Column Profiler'",
        "When no column is selected, sidebar shows placeholder text: 'Click a column header to inspect'",
        "Sidebar has a minimum width of 240pt and can be resized via the split view divider",
        "The table area resizes fluidly when sidebar appears/disappears (animates collapse/expand)",
        "Sidebar visibility state persists across sessions",
        "Compiles and runs without crashes"
      ],
      "priority": 3,
      "passes": true,
      "notes": "Follow the pattern of DetailPaneView (existing right sidebar). Use NSSplitView with the table on the left and profiler on the right. The profiler sidebar is a new ProfilerSidebarViewController. Add profilerVisible: Bool to ViewState."
    },
    {
      "id": "US-004",
      "title": "Show column overview stats in profiler",
      "description": "As a user, I want to see the selected column's type, row count, unique count, null count, and completeness at a glance in the profiler sidebar.",
      "acceptanceCriteria": [
        "Profiler header shows: column name (bold, 16pt) and type badge (colored: green=INTEGER, blue=VARCHAR, orange=FLOAT, purple=BOOLEAN, red=DATE)",
        "Overview section shows: Rows, Unique, Nulls, Empty in a 2×2 grid layout",
        "A completeness bar shows percentage of non-null values (green ≥90%, orange 50–89%, red <50%)",
        "Data fetched via: SELECT COUNT(*), COUNT(DISTINCT col), COUNT(*) - COUNT(col), SUM(CASE WHEN CAST(col AS VARCHAR) = '' THEN 1 ELSE 0 END) FROM data WHERE ...",
        "Query runs on the serial DuckDB DispatchQueue; UI updates on main thread",
        "Results update when a different column is selected (debounced at 200ms if clicking rapidly between columns)",
        "Compiles and runs without crashes"
      ],
      "priority": 4,
      "passes": true,
      "notes": "This is the first profiler content section. Create a ProfilerQueryBuilder helper that generates the overview SQL from column name and ViewState (including current filters). The query must include WHERE clause from ViewState so profiler reflects filtered data."
    },
    {
      "id": "US-005",
      "title": "Show distribution histogram in profiler",
      "description": "As a user, I want to see a histogram of value distribution in the profiler so I can understand the shape of the data.",
      "acceptanceCriteria": [
        "Distribution section shows a horizontal bar chart with 8–12 bars drawn with Core Graphics",
        "For numeric columns (INTEGER, FLOAT): bars represent equal-width bins using WIDTH_BUCKET()",
        "For categorical columns (VARCHAR with ≤50 unique values): bars represent top values by count",
        "For high-cardinality VARCHAR (>50 unique): show top 10 values as bars with 'and N more...' label",
        "For BOOLEAN: show two bars (true/false) with percentage labels",
        "Hovering over a bar shows a tooltip with the bucket range/value and count",
        "Min and max labels appear below the chart for numeric columns",
        "Compiles and runs without crashes"
      ],
      "priority": 5,
      "passes": true,
      "notes": "Create a custom HistogramView (NSView subclass) that draws bars with Core Graphics. The data comes from ProfilerQueryBuilder queries: WIDTH_BUCKET for numeric, GROUP BY ORDER BY cnt DESC for categorical. Accept an array of (label, count) tuples for rendering."
    },
    {
      "id": "US-006",
      "title": "Show descriptive statistics in profiler for numeric columns",
      "description": "As a user, I want to see min, max, mean, median, standard deviation, and quartiles for numeric columns in the profiler.",
      "acceptanceCriteria": [
        "Statistics section appears for INTEGER and FLOAT columns only; hidden for others",
        "Shows in a grid layout: Min, Max, Mean, Median, Std Dev, Q1, Q3, IQR",
        "Values formatted with appropriate precision (integers: no decimals, floats: 2 decimals)",
        "Large numbers use thousands separators (e.g., 12,400)",
        "Data fetched via: SELECT MIN(col), MAX(col), AVG(col), MEDIAN(col), STDDEV(col), QUANTILE_CONT(col, 0.25), QUANTILE_CONT(col, 0.75) FROM data WHERE ...",
        "Compiles and runs without crashes"
      ],
      "priority": 6,
      "passes": false,
      "notes": "This extends the profiler sidebar with a Statistics section below Distribution. Use NumberFormatter for locale-aware formatting. IQR = Q3 - Q1 (computed in Swift from the query results)."
    },
    {
      "id": "US-007",
      "title": "Show top values list with click-to-filter in profiler",
      "description": "As a user, I want to see the most frequent values in a column and click one to instantly filter the table to that value.",
      "acceptanceCriteria": [
        "Top Values section shows up to 10 most frequent values",
        "Each row shows: value text, mini horizontal bar (proportional to count), count, percentage",
        "Clicking a value row adds a filter: column = value (updates ViewState filters)",
        "For all-unique columns, show message: 'All N values are unique'",
        "A 'Show full frequency →' link at the bottom is present (functional once Frequency panel exists in US-010)",
        "Data fetched via: SELECT col, COUNT(*) as cnt FROM data GROUP BY col ORDER BY cnt DESC LIMIT 10",
        "Compiles and runs without crashes"
      ],
      "priority": 7,
      "passes": false,
      "notes": "The click-to-filter should use the existing filter infrastructure (add a ColumnFilter to ViewState.filters). The 'Show full frequency' link can be a placeholder button initially — it will become active when US-010 is implemented."
    },
    {
      "id": "US-008",
      "title": "Batch profiler queries for performance",
      "description": "As a developer, I need to batch the profiler's multiple queries efficiently so the profiler updates quickly, with loading indicators and cancellation.",
      "acceptanceCriteria": [
        "Overview stats (count, distinct, nulls, empty) are fetched in a single query",
        "Statistics (min, max, mean, etc.) are fetched in a single query",
        "Distribution and top values queries are dispatched sequentially on the serial queue",
        "All queries include the current filter/search conditions from ViewState",
        "Total profiler load time is <1s for files up to 1M rows",
        "A loading indicator (spinner or progress text) appears in the sidebar while queries are in flight",
        "If the user selects a different column while queries are running, in-flight results are discarded (use a generation counter or cancellation token)",
        "Compiles and runs without crashes"
      ],
      "priority": 8,
      "passes": false,
      "notes": "Use a generation counter pattern: increment a counter when column selection changes, and discard results whose generation doesn't match current. This prevents stale data from appearing. Log query times with os_log when GRIDKA_LOG_SQL=1."
    },
    {
      "id": "US-009",
      "title": "Add 'Value Frequency...' to column header context menu",
      "description": "As a user, I want a 'Value Frequency...' option in the column header right-click menu that will open the frequency panel for that column.",
      "acceptanceCriteria": [
        "Right-click on column header context menu includes a new 'Value Frequency...' item after existing items",
        "Clicking the menu item stores the target column and triggers the frequency panel open action",
        "If the frequency panel feature is not yet implemented, the menu item is present but shows the column name in a logged message (placeholder behavior)",
        "Compiles and runs without crashes"
      ],
      "priority": 9,
      "passes": false,
      "notes": "This is a small story that adds the menu item trigger point. The actual frequency panel is built in US-010. For now, clicking the item can just log or store the intent. Update the existing column header context menu builder."
    },
    {
      "id": "US-010",
      "title": "Create frequency floating panel (NSPanel)",
      "description": "As a user, I want a floating panel that shows the complete value frequency table for a column, so I can explore all values beyond the profiler's top 10.",
      "acceptanceCriteria": [
        "An NSPanel (floating, non-modal, .utilityWindow style) displays the frequency table",
        "Panel title shows: 'Column Name — Value Frequency'",
        "Panel has a close button and can be dismissed with Escape",
        "Panel floats above the main window but does not block interaction with the table",
        "Panel position is remembered within the session (not persisted across launches)",
        "Triggered by: right-click column header → 'Value Frequency...' (US-009), toolbar Frequency button, or profiler's 'Show full frequency →' link",
        "Compiles and runs without crashes"
      ],
      "priority": 10,
      "passes": false,
      "notes": "Create a FrequencyPanelController managing an NSPanel. The panel should be similar to macOS Font panel or Colors panel in behavior. Use NSPanel with .utilityWindow and .nonactivatingPanel style masks."
    },
    {
      "id": "US-011",
      "title": "Frequency table with sortable columns and inline bars",
      "description": "As a user, I want a sortable table showing rank, value, count, and percentage for every distinct value in the column.",
      "acceptanceCriteria": [
        "Table columns: Rank (#), Value, Count, Percentage (%)",
        "Each row includes an inline colored percentage bar in the Count or % column (drawn with Core Graphics or NSLevelIndicator)",
        "Table is sortable by clicking column headers (by count desc is default, can sort by value or %)",
        "Table scrolls for columns with many distinct values (virtual scrolling if >1000 rows)",
        "For numeric columns with >50 distinct values, offer a 'Bin values' toggle that switches to histogram mode (10 equal-width bins)",
        "Data fetched via: SELECT col, COUNT(*) as cnt FROM data GROUP BY col ORDER BY cnt DESC (with ViewState WHERE clause)",
        "Compiles and runs without crashes"
      ],
      "priority": 11,
      "passes": false,
      "notes": "Use NSTableView inside the frequency panel. The inline percentage bar can be a custom NSTableCellView with a colored background view proportional to the percentage. For the 'Bin values' toggle, switch the query to use WIDTH_BUCKET."
    },
    {
      "id": "US-012",
      "title": "Frequency bar chart alongside table",
      "description": "As a user, I want a horizontal bar chart alongside the frequency table for visual comparison of value counts.",
      "acceptanceCriteria": [
        "A horizontal bar chart appears to the right of the frequency table (or togglable between table-only and table+chart views)",
        "Each bar corresponds to a row in the frequency table",
        "Bar width is proportional to count (largest value = full width)",
        "Bars are drawn with Core Graphics in a custom NSView",
        "Chart scrolls in sync with the table (linked scroll views)",
        "Compiles and runs without crashes"
      ],
      "priority": 12,
      "passes": false,
      "notes": "The bar chart can be a separate NSView in an NSSplitView with the table. Synchronize scrolling by observing NSScrollView.boundsDidChangeNotification on both scroll views. Bars should use the system accent color."
    },
    {
      "id": "US-013",
      "title": "Click-to-filter from frequency view",
      "description": "As a user, I want to click a value in the frequency table to instantly filter the main table to that value.",
      "acceptanceCriteria": [
        "Single-clicking a row in the frequency table adds a filter: column = value to ViewState",
        "The filter appears as a chip in the main window's filter bar",
        "The frequency panel remains open after filtering (so user can click another value)",
        "Double-clicking a row filters AND closes the frequency panel",
        "If a filter for this column already exists, it is replaced (not duplicated)",
        "Status bar updates to show 'showing X of Y rows'",
        "Compiles and runs without crashes"
      ],
      "priority": 13,
      "passes": false,
      "notes": "Use the existing filter infrastructure — create a ColumnFilter with .equals operator and add it to ViewState.filters. Post a notification or use a delegate pattern so the main window controller can observe the filter change from the floating panel."
    },
    {
      "id": "US-014",
      "title": "Compute and cache column summaries on file load",
      "description": "As a developer, I need to compute lightweight summary data for each column once when a file loads, so sparklines can render instantly without per-column queries.",
      "acceptanceCriteria": [
        "After full file load completes (CREATE TABLE), compute a ColumnSummary struct for each column",
        "ColumnSummary contains: detected type, cardinality (distinct count), null count, and distribution data (histogram buckets for numeric, top-N counts for categorical, true/false counts for boolean)",
        "Summaries are computed using a batch of targeted DuckDB queries (not one per column — batch where possible)",
        "Summaries are stored on FileSession or the tab context and invalidated when underlying data changes (cell edit, row delete)",
        "Computation completes in <2s for files up to 1M rows",
        "Compiles and runs without crashes"
      ],
      "priority": 14,
      "passes": false,
      "notes": "Create a ColumnSummary struct and a Distribution enum with cases: .histogram(buckets: [(range: String, count: Int)]), .frequency(values: [(value: String, count: Int)]), .boolean(trueCount: Int, falseCount: Int), .highCardinality(uniqueCount: Int). Batch queries: one for cardinality/nulls across all columns, then per-column distribution queries."
    },
    {
      "id": "US-015",
      "title": "Render sparklines in column headers",
      "description": "As a user, I want to see tiny distribution charts in each column header so I can understand data shape at a glance without clicking anything.",
      "acceptanceCriteria": [
        "Each column header shows a small (~16pt height) visualization below the column name",
        "Numeric columns: mini histogram bars (8–10 bars) showing distribution shape",
        "Low-cardinality categorical (≤15 unique): mini frequency bars (top values, decreasing height)",
        "High-cardinality text (>15 unique): text badge showing 'N unique' in secondary color",
        "Boolean: two-segment horizontal bar with percentage labels (e.g., green 65% / red 35%)",
        "Sparklines drawn with Core Graphics in a custom NSTableHeaderCell subclass or NSView overlay",
        "Header row height increases to ~44pt to accommodate the sparkline row",
        "Sparklines use cached ColumnSummary data — no queries on render",
        "Compiles and runs without crashes"
      ],
      "priority": 15,
      "passes": false,
      "notes": "This requires subclassing NSTableHeaderCell or adding NSView overlays to the header view. Core Graphics drawing should be lightweight — just rectangles with rounded corners and colors. Use system colors that respect dark mode. The header height change affects the NSTableHeaderView."
    },
    {
      "id": "US-016",
      "title": "Click sparkline to open profiler for that column",
      "description": "As a user, I want to click a sparkline to see the full profile for that column, opening the profiler if needed.",
      "acceptanceCriteria": [
        "Clicking the sparkline area (lower ~16pt) of a column header selects that column AND opens the Profiler sidebar if not already open",
        "If the Profiler is already open, clicking a sparkline just switches to that column",
        "The sparkline click target is distinct from the column name area (which follows US-001 select behavior)",
        "Compiles and runs without crashes"
      ],
      "priority": 16,
      "passes": false,
      "notes": "Hit-test the click position within the header cell — if in the lower sparkline region, trigger profiler open + column select. If in the upper name region, just column select (per US-001)."
    },
    {
      "id": "US-017",
      "title": "Computed column dialog with expression editor",
      "description": "As a user, I want a dialog where I can name a new column and write a DuckDB SQL expression to derive new values from existing columns.",
      "acceptanceCriteria": [
        "An NSPanel or sheet opens with: Column Name text field, Expression multi-line text area (monospace font)",
        "Triggered by: toolbar 'Computed Column' button, Opt+Cmd+F shortcut, or Edit menu → 'Add Computed Column...'",
        "Below the expression field, show clickable function hint chips: ROUND, UPPER, LOWER, LENGTH, YEAR, MONTH, CASE...END, CONCAT, COALESCE, CAST, REGEXP_EXTRACT, TRIM, REPLACE, SUBSTR",
        "Clicking a hint chip inserts the function template at cursor position in the expression field",
        "Dialog has Cancel and 'Add Column' buttons; 'Add Column' disabled until both fields are non-empty",
        "Compiles and runs without crashes"
      ],
      "priority": 17,
      "passes": false,
      "notes": "Use NSPanel with .titled and .closable style. The expression text area should be an NSTextView with monospace font (NSFont.monospacedSystemFont). Function chips can be NSButton instances in a flow layout (NSStackView wrapping). Insert templates like 'ROUND(, 2)' with cursor positioned inside."
    },
    {
      "id": "US-018",
      "title": "Live preview for computed column expression",
      "description": "As a user, I want to see a preview of the computed values before adding the column, so I can verify my expression is correct.",
      "acceptanceCriteria": [
        "A Preview section below the expression field shows a small table with the first 5 rows",
        "Preview table shows 2–3 existing columns for context plus the new computed column (highlighted with background color)",
        "Preview updates 300ms after the user stops typing (debounced)",
        "If the expression has a syntax error, show the DuckDB error message in red below the expression field instead of the preview table",
        "Preview query: SELECT col1, col2, (expression) AS new_col FROM data LIMIT 5",
        "Query runs on the serial DuckDB queue; preview updates on main thread",
        "Compiles and runs without crashes"
      ],
      "priority": 18,
      "passes": false,
      "notes": "Use a small NSTableView (5 rows, non-scrollable) for the preview. Debounce using DispatchWorkItem — cancel previous work item on each keystroke, schedule new one after 300ms. Catch DuckDB errors and display them in a red NSTextField."
    },
    {
      "id": "US-019",
      "title": "Add computed column to table and QueryCoordinator",
      "description": "As a user, I want the computed column to appear in the table when I click 'Add Column', working like a regular column for sort, filter, and search.",
      "acceptanceCriteria": [
        "Clicking 'Add Column' adds a ComputedColumn definition (name + expression) to ViewState.computedColumns",
        "QueryCoordinator includes computed columns in SELECT: SELECT *, (expr1) AS name1, (expr2) AS name2 FROM data ...",
        "New column appears as the rightmost column in the table",
        "Column header shows computed column name with a distinguishing indicator (italic text or formula icon ƒ)",
        "Computed columns can be sorted, filtered, and searched like regular columns",
        "Computed columns can be removed via right-click header → 'Remove Computed Column'",
        "Multiple computed columns can coexist",
        "Compiles and runs without crashes"
      ],
      "priority": 19,
      "passes": false,
      "notes": "Add computedColumns: [ComputedColumn] to ViewState. ComputedColumn is a struct with name: String and expression: String. QueryCoordinator.buildSelectClause() appends computed columns. The table's column list needs to include computed columns when refreshing columns."
    },
    {
      "id": "US-020",
      "title": "Save As prompt for tabs with computed columns",
      "description": "As a user, when I close a tab that has computed columns, I want the option to save a new CSV with the computed values materialized.",
      "acceptanceCriteria": [
        "When closing a tab with computed columns, show an NSAlert: 'This tab has computed columns. Save a copy with computed values included?'",
        "Alert options: 'Save As...' (opens NSSavePanel), 'Discard' (closes without saving), 'Cancel' (stays on tab)",
        "Save As exports all rows including computed columns as a new CSV file via DuckDB COPY statement",
        "Export query includes computed columns: SELECT *, (expr1) AS name1 FROM data (no LIMIT)",
        "Export runs on the serial DuckDB queue with a progress indicator for large files",
        "The original file is never modified",
        "Compiles and runs without crashes"
      ],
      "priority": 20,
      "passes": false,
      "notes": "Use DuckDB's COPY TO for CSV export: COPY (SELECT *, computed_cols FROM data) TO 'path.csv' (HEADER, DELIMITER ','). Show NSProgressIndicator during export. The Save As file path comes from NSSavePanel."
    },
    {
      "id": "US-021",
      "title": "Group By builder dialog with column zones",
      "description": "As a user, I want a visual builder where I can pick grouping columns and aggregation functions to create summary tables without writing SQL.",
      "acceptanceCriteria": [
        "An NSPanel opens with three areas: Available Columns (left list), Group By zone (top-right), Aggregations zone (bottom-right)",
        "Available Columns list shows all columns with color-coded type dots (blue=VARCHAR, green=INTEGER/FLOAT, purple=BOOLEAN)",
        "Clicking a column adds it to Group By (if categorical) or Aggregations (if numeric) as default action",
        "Group By zone shows columns as removable pills with × buttons",
        "Aggregations zone shows columns as pills with a function dropdown (COUNT, SUM, AVG, MIN, MAX, MEDIAN)",
        "A COUNT(*) aggregation is added by default",
        "Columns can be added to either zone regardless of type via a secondary action (e.g., double-click or drag)",
        "Triggered by: toolbar 'Group By' button, Opt+Cmd+G shortcut, or Edit menu → 'Group By...'",
        "Dialog has Cancel and 'Open as New Tab' buttons",
        "Compiles and runs without crashes"
      ],
      "priority": 21,
      "passes": false,
      "notes": "The Available Columns list is an NSTableView or NSOutlineView. The Group By and Aggregations zones use NSStackView with pill-style NSViews. The function dropdown on aggregation pills is an NSPopUpButton. Use click-to-add (not drag-and-drop) for simplicity."
    },
    {
      "id": "US-022",
      "title": "Live preview for Group By results",
      "description": "As a user, I want to see a preview of the aggregation results before creating the full summary, so I can refine my grouping choices.",
      "acceptanceCriteria": [
        "A preview table shows the top 5 groups (by count descending)",
        "Preview updates within 500ms of any change to group-by or aggregation configuration (debounced)",
        "Preview query: SELECT group_cols, agg_functions FROM data WHERE current_filters GROUP BY group_cols ORDER BY COUNT(*) DESC LIMIT 5",
        "Preview shows a row count label: 'N groups total'",
        "If no group-by columns are selected, preview shows overall aggregation (single row)",
        "Query runs on the serial DuckDB queue",
        "Compiles and runs without crashes"
      ],
      "priority": 22,
      "passes": false,
      "notes": "Similar debounce pattern as computed column preview (US-018). The group count can be obtained with a separate COUNT query or by using a window function. Preview table is a small NSTableView with dynamic columns based on the selected aggregations."
    },
    {
      "id": "US-023",
      "title": "Open Group By results as new tab",
      "description": "As a user, I want to open the full aggregation results in a new tab so I can scroll, sort, and explore the summary data like any other table.",
      "acceptanceCriteria": [
        "Clicking 'Open as New Tab' creates a new tab titled 'Summary: by [column_names]'",
        "The tab displays all group-by results in the standard table view (not just top 5)",
        "Summary tab is backed by a temp table: CREATE TEMP TABLE summary_N AS SELECT group_cols, aggs FROM data GROUP BY ...",
        "Summary tab supports sorting by clicking headers (standard sort, not profiler-click since it's a summary)",
        "Summary tab supports Profiler, Frequency, and Quick Charts features (treated like any data tab)",
        "Summary tab's status bar shows group count (e.g., '20 groups')",
        "Closing the summary tab drops the temp table (DROP TABLE IF EXISTS summary_N)",
        "Compiles and runs without crashes"
      ],
      "priority": 23,
      "passes": false,
      "notes": "Create the temp table on the serial DuckDB queue, then open a new tab pointing to it. The tab's FileSession (or a new SummarySession) should track the temp table name. On tab close, drop the temp table. Use an incrementing counter for unique temp table names (summary_1, summary_2, etc.)."
    }
  ]
}
